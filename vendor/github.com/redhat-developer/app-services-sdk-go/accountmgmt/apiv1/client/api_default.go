/*
 * Account Management Service API
 *
 * Manage user subscriptions and clusters
 *
 * API version: 0.0.1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package accountmgmtclient

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type DefaultApi interface {

	/*
	 * ApiAccountsMgmtV1AccountsGet Returns a list of accounts
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1AccountsGetRequest
	 */
	ApiAccountsMgmtV1AccountsGet(ctx _context.Context) ApiApiAccountsMgmtV1AccountsGetRequest

	/*
	 * ApiAccountsMgmtV1AccountsGetExecute executes the request
	 * @return AccountList
	 */
	ApiAccountsMgmtV1AccountsGetExecute(r ApiApiAccountsMgmtV1AccountsGetRequest) (AccountList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1AccountsIdGet Get an account by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1AccountsIdGetRequest
	 */
	ApiAccountsMgmtV1AccountsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1AccountsIdGetRequest

	/*
	 * ApiAccountsMgmtV1AccountsIdGetExecute executes the request
	 * @return Account
	 */
	ApiAccountsMgmtV1AccountsIdGetExecute(r ApiApiAccountsMgmtV1AccountsIdGetRequest) (Account, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsGet Returns a list of labels
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest
	 */
	ApiAccountsMgmtV1AccountsIdLabelsGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsGetExecute executes the request
	 * @return LabelList
	 */
	ApiAccountsMgmtV1AccountsIdLabelsGetExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest) (LabelList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsKeyDelete Delete a label
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param key The key of the label
	 * @return ApiApiAccountsMgmtV1AccountsIdLabelsKeyDeleteRequest
	 */
	ApiAccountsMgmtV1AccountsIdLabelsKeyDelete(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1AccountsIdLabelsKeyDeleteRequest

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsKeyDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1AccountsIdLabelsKeyDeleteExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsKeyDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsKeyGet Get subscription labels by label key
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param key The key of the label
	 * @return ApiApiAccountsMgmtV1AccountsIdLabelsKeyGetRequest
	 */
	ApiAccountsMgmtV1AccountsIdLabelsKeyGet(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1AccountsIdLabelsKeyGetRequest

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsKeyGetExecute executes the request
	 * @return Label
	 */
	ApiAccountsMgmtV1AccountsIdLabelsKeyGetExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsKeyGetRequest) (Label, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsKeyPatch Create a new label or update an existing label
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param key The key of the label
	 * @return ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest
	 */
	ApiAccountsMgmtV1AccountsIdLabelsKeyPatch(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsKeyPatchExecute executes the request
	 * @return Label
	 */
	ApiAccountsMgmtV1AccountsIdLabelsKeyPatchExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest) (Label, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsPost Create a new label or update an existing label
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest
	 */
	ApiAccountsMgmtV1AccountsIdLabelsPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsPostExecute executes the request
	 * @return Label
	 */
	ApiAccountsMgmtV1AccountsIdLabelsPostExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest) (Label, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1AccountsIdPatch Update an account
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1AccountsIdPatchRequest
	 */
	ApiAccountsMgmtV1AccountsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1AccountsIdPatchRequest

	/*
	 * ApiAccountsMgmtV1AccountsIdPatchExecute executes the request
	 * @return Account
	 */
	ApiAccountsMgmtV1AccountsIdPatchExecute(r ApiApiAccountsMgmtV1AccountsIdPatchRequest) (Account, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1AccountsPost Create a new account
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1AccountsPostRequest
	 */
	ApiAccountsMgmtV1AccountsPost(ctx _context.Context) ApiApiAccountsMgmtV1AccountsPostRequest

	/*
	 * ApiAccountsMgmtV1AccountsPostExecute executes the request
	 * @return Account
	 */
	ApiAccountsMgmtV1AccountsPostExecute(r ApiApiAccountsMgmtV1AccountsPostRequest) (Account, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1CertificatesPost Fetch certificates of a particular type
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1CertificatesPostRequest
	 */
	ApiAccountsMgmtV1CertificatesPost(ctx _context.Context) ApiApiAccountsMgmtV1CertificatesPostRequest

	/*
	 * ApiAccountsMgmtV1CertificatesPostExecute executes the request
	 * @return Certificate
	 */
	ApiAccountsMgmtV1CertificatesPostExecute(r ApiApiAccountsMgmtV1CertificatesPostRequest) (Certificate, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1CloudResourcesGet Returns a list of cloud resources
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1CloudResourcesGetRequest
	 */
	ApiAccountsMgmtV1CloudResourcesGet(ctx _context.Context) ApiApiAccountsMgmtV1CloudResourcesGetRequest

	/*
	 * ApiAccountsMgmtV1CloudResourcesGetExecute executes the request
	 * @return CloudResourceList
	 */
	ApiAccountsMgmtV1CloudResourcesGetExecute(r ApiApiAccountsMgmtV1CloudResourcesGetRequest) (CloudResourceList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1CloudResourcesIdDelete Delete a cloud resource
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1CloudResourcesIdDeleteRequest
	 */
	ApiAccountsMgmtV1CloudResourcesIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1CloudResourcesIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1CloudResourcesIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1CloudResourcesIdDeleteExecute(r ApiApiAccountsMgmtV1CloudResourcesIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1CloudResourcesIdGet Get a cloud resource
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1CloudResourcesIdGetRequest
	 */
	ApiAccountsMgmtV1CloudResourcesIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1CloudResourcesIdGetRequest

	/*
	 * ApiAccountsMgmtV1CloudResourcesIdGetExecute executes the request
	 * @return CloudResource
	 */
	ApiAccountsMgmtV1CloudResourcesIdGetExecute(r ApiApiAccountsMgmtV1CloudResourcesIdGetRequest) (CloudResource, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1CloudResourcesIdPatch Update a cloud resource
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1CloudResourcesIdPatchRequest
	 */
	ApiAccountsMgmtV1CloudResourcesIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1CloudResourcesIdPatchRequest

	/*
	 * ApiAccountsMgmtV1CloudResourcesIdPatchExecute executes the request
	 * @return CloudResource
	 */
	ApiAccountsMgmtV1CloudResourcesIdPatchExecute(r ApiApiAccountsMgmtV1CloudResourcesIdPatchRequest) (CloudResource, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1CloudResourcesPost Create a new cloud resource
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1CloudResourcesPostRequest
	 */
	ApiAccountsMgmtV1CloudResourcesPost(ctx _context.Context) ApiApiAccountsMgmtV1CloudResourcesPostRequest

	/*
	 * ApiAccountsMgmtV1CloudResourcesPostExecute executes the request
	 * @return CloudResource
	 */
	ApiAccountsMgmtV1CloudResourcesPostExecute(r ApiApiAccountsMgmtV1CloudResourcesPostRequest) (CloudResource, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ClusterAuthorizationsPost Authorizes new cluster creation against an exsiting RH Subscription.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest
	 */
	ApiAccountsMgmtV1ClusterAuthorizationsPost(ctx _context.Context) ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest

	/*
	 * ApiAccountsMgmtV1ClusterAuthorizationsPostExecute executes the request
	 * @return ClusterAuthorizationResponse
	 */
	ApiAccountsMgmtV1ClusterAuthorizationsPostExecute(r ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest) (ClusterAuthorizationResponse, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ClusterRegistrationsPost Finds or creates a cluster registration with a registy credential token and cluster ID
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest
	 */
	ApiAccountsMgmtV1ClusterRegistrationsPost(ctx _context.Context) ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest

	/*
	 * ApiAccountsMgmtV1ClusterRegistrationsPostExecute executes the request
	 * @return ClusterRegistrationResponse
	 */
	ApiAccountsMgmtV1ClusterRegistrationsPostExecute(r ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest) (ClusterRegistrationResponse, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ClusterTransfersGet List cluster transfers - returns either an empty result set or a valid ClusterTransfer instance that is within a valid transfer window.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1ClusterTransfersGetRequest
	 */
	ApiAccountsMgmtV1ClusterTransfersGet(ctx _context.Context) ApiApiAccountsMgmtV1ClusterTransfersGetRequest

	/*
	 * ApiAccountsMgmtV1ClusterTransfersGetExecute executes the request
	 * @return ClusterTransferList
	 */
	ApiAccountsMgmtV1ClusterTransfersGetExecute(r ApiApiAccountsMgmtV1ClusterTransfersGetRequest) (ClusterTransferList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ClusterTransfersIdPatch Update specific cluster transfer
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1ClusterTransfersIdPatchRequest
	 */
	ApiAccountsMgmtV1ClusterTransfersIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1ClusterTransfersIdPatchRequest

	/*
	 * ApiAccountsMgmtV1ClusterTransfersIdPatchExecute executes the request
	 * @return ClusterTransfer
	 */
	ApiAccountsMgmtV1ClusterTransfersIdPatchExecute(r ApiApiAccountsMgmtV1ClusterTransfersIdPatchRequest) (ClusterTransfer, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ClusterTransfersPost Initiate cluster transfer.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1ClusterTransfersPostRequest
	 */
	ApiAccountsMgmtV1ClusterTransfersPost(ctx _context.Context) ApiApiAccountsMgmtV1ClusterTransfersPostRequest

	/*
	 * ApiAccountsMgmtV1ClusterTransfersPostExecute executes the request
	 * @return ClusterTransfer
	 */
	ApiAccountsMgmtV1ClusterTransfersPostExecute(r ApiApiAccountsMgmtV1ClusterTransfersPostRequest) (ClusterTransfer, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ConfigSkusGet Returns a list of skus
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1ConfigSkusGetRequest
	 */
	ApiAccountsMgmtV1ConfigSkusGet(ctx _context.Context) ApiApiAccountsMgmtV1ConfigSkusGetRequest

	/*
	 * ApiAccountsMgmtV1ConfigSkusGetExecute executes the request
	 * @return SkuList
	 */
	ApiAccountsMgmtV1ConfigSkusGetExecute(r ApiApiAccountsMgmtV1ConfigSkusGetRequest) (SkuList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ConfigSkusIdDelete Delete a sku
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1ConfigSkusIdDeleteRequest
	 */
	ApiAccountsMgmtV1ConfigSkusIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1ConfigSkusIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1ConfigSkusIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1ConfigSkusIdDeleteExecute(r ApiApiAccountsMgmtV1ConfigSkusIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ConfigSkusIdGet Get a sku
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1ConfigSkusIdGetRequest
	 */
	ApiAccountsMgmtV1ConfigSkusIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1ConfigSkusIdGetRequest

	/*
	 * ApiAccountsMgmtV1ConfigSkusIdGetExecute executes the request
	 * @return SKU
	 */
	ApiAccountsMgmtV1ConfigSkusIdGetExecute(r ApiApiAccountsMgmtV1ConfigSkusIdGetRequest) (SKU, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ConfigSkusIdPatch Update a Sku
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1ConfigSkusIdPatchRequest
	 */
	ApiAccountsMgmtV1ConfigSkusIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1ConfigSkusIdPatchRequest

	/*
	 * ApiAccountsMgmtV1ConfigSkusIdPatchExecute executes the request
	 * @return SKU
	 */
	ApiAccountsMgmtV1ConfigSkusIdPatchExecute(r ApiApiAccountsMgmtV1ConfigSkusIdPatchRequest) (SKU, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ConfigSkusPost Create a new sku
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1ConfigSkusPostRequest
	 */
	ApiAccountsMgmtV1ConfigSkusPost(ctx _context.Context) ApiApiAccountsMgmtV1ConfigSkusPostRequest

	/*
	 * ApiAccountsMgmtV1ConfigSkusPostExecute executes the request
	 * @return SKU
	 */
	ApiAccountsMgmtV1ConfigSkusPostExecute(r ApiApiAccountsMgmtV1ConfigSkusPostRequest) (SKU, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1DeletedSubscriptionsGet Returns a list of deleted subscriptions
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1DeletedSubscriptionsGetRequest
	 */
	ApiAccountsMgmtV1DeletedSubscriptionsGet(ctx _context.Context) ApiApiAccountsMgmtV1DeletedSubscriptionsGetRequest

	/*
	 * ApiAccountsMgmtV1DeletedSubscriptionsGetExecute executes the request
	 * @return DeletedSubscriptionList
	 */
	ApiAccountsMgmtV1DeletedSubscriptionsGetExecute(r ApiApiAccountsMgmtV1DeletedSubscriptionsGetRequest) (DeletedSubscriptionList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ErrorsGet Returns a list of errors
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1ErrorsGetRequest
	 */
	ApiAccountsMgmtV1ErrorsGet(ctx _context.Context) ApiApiAccountsMgmtV1ErrorsGetRequest

	/*
	 * ApiAccountsMgmtV1ErrorsGetExecute executes the request
	 * @return ErrorList
	 */
	ApiAccountsMgmtV1ErrorsGetExecute(r ApiApiAccountsMgmtV1ErrorsGetRequest) (ErrorList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ErrorsIdGet Get an error by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1ErrorsIdGetRequest
	 */
	ApiAccountsMgmtV1ErrorsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1ErrorsIdGetRequest

	/*
	 * ApiAccountsMgmtV1ErrorsIdGetExecute executes the request
	 * @return Error
	 */
	ApiAccountsMgmtV1ErrorsIdGetExecute(r ApiApiAccountsMgmtV1ErrorsIdGetRequest) (Error, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1FeatureTogglesIdQueryPost Query a feature toggle by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest
	 */
	ApiAccountsMgmtV1FeatureTogglesIdQueryPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest

	/*
	 * ApiAccountsMgmtV1FeatureTogglesIdQueryPostExecute executes the request
	 * @return FeatureToggle
	 */
	ApiAccountsMgmtV1FeatureTogglesIdQueryPostExecute(r ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest) (FeatureToggle, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1LabelsGet Returns a list of labels
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1LabelsGetRequest
	 */
	ApiAccountsMgmtV1LabelsGet(ctx _context.Context) ApiApiAccountsMgmtV1LabelsGetRequest

	/*
	 * ApiAccountsMgmtV1LabelsGetExecute executes the request
	 * @return LabelList
	 */
	ApiAccountsMgmtV1LabelsGetExecute(r ApiApiAccountsMgmtV1LabelsGetRequest) (LabelList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1LandingPageSelfServiceGet Get a console.redhat.com landing page content JSON schema
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1LandingPageSelfServiceGetRequest
	 */
	ApiAccountsMgmtV1LandingPageSelfServiceGet(ctx _context.Context) ApiApiAccountsMgmtV1LandingPageSelfServiceGetRequest

	/*
	 * ApiAccountsMgmtV1LandingPageSelfServiceGetExecute executes the request
	 * @return SelfServiceLandingPageSchema
	 */
	ApiAccountsMgmtV1LandingPageSelfServiceGetExecute(r ApiApiAccountsMgmtV1LandingPageSelfServiceGetRequest) (SelfServiceLandingPageSchema, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1MetricsGet Returns a list of metrics
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1MetricsGetRequest
	 */
	ApiAccountsMgmtV1MetricsGet(ctx _context.Context) ApiApiAccountsMgmtV1MetricsGetRequest

	/*
	 * ApiAccountsMgmtV1MetricsGetExecute executes the request
	 * @return MetricsList
	 */
	ApiAccountsMgmtV1MetricsGetExecute(r ApiApiAccountsMgmtV1MetricsGetRequest) (MetricsList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1NotifyPost Notify the owner of cluster/subscription
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1NotifyPostRequest
	 */
	ApiAccountsMgmtV1NotifyPost(ctx _context.Context) ApiApiAccountsMgmtV1NotifyPostRequest

	/*
	 * ApiAccountsMgmtV1NotifyPostExecute executes the request
	 */
	ApiAccountsMgmtV1NotifyPostExecute(r ApiApiAccountsMgmtV1NotifyPostRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsGet Returns a list of organizations
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1OrganizationsGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsGet(ctx _context.Context) ApiApiAccountsMgmtV1OrganizationsGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsGetExecute executes the request
	 * @return OrganizationList
	 */
	ApiAccountsMgmtV1OrganizationsGetExecute(r ApiApiAccountsMgmtV1OrganizationsGetRequest) (OrganizationList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsIdGet Get an organization by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1OrganizationsIdGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsIdGetExecute executes the request
	 * @return Organization
	 */
	ApiAccountsMgmtV1OrganizationsIdGetExecute(r ApiApiAccountsMgmtV1OrganizationsIdGetRequest) (Organization, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsGet Returns a list of labels
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsGetExecute executes the request
	 * @return LabelList
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsGetExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest) (LabelList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsKeyDelete Delete a label
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param key The key of the label
	 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteRequest
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsKeyDelete(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsKeyGet Get subscription labels by label key
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param key The key of the label
	 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsKeyGet(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsKeyGetExecute executes the request
	 * @return Label
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsKeyGetExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyGetRequest) (Label, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsKeyPatch Create a new label or update an existing label
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param key The key of the label
	 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsKeyPatch(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchExecute executes the request
	 * @return Label
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest) (Label, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsPost Create a new label or update an existing label
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsPostExecute executes the request
	 * @return Label
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsPostExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest) (Label, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsIdPatch Update an organization
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1OrganizationsIdPatchRequest
	 */
	ApiAccountsMgmtV1OrganizationsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdPatchRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsIdPatchExecute executes the request
	 * @return Organization
	 */
	ApiAccountsMgmtV1OrganizationsIdPatchExecute(r ApiApiAccountsMgmtV1OrganizationsIdPatchRequest) (Organization, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsIdSummaryDashboardGet Returns a summary of organizations clusters based on metrics
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsIdSummaryDashboardGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetExecute executes the request
	 * @return Summary
	 */
	ApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetExecute(r ApiApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetRequest) (Summary, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdDelete Delete an account group assignment
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @param acctGrpAsgnId The id of account group assignment
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdDeleteRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdDelete(ctx _context.Context, orgId string, acctGrpAsgnId string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdDeleteExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdGet Get account group assignment by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @param acctGrpAsgnId The id of account group assignment
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdGet(ctx _context.Context, orgId string, acctGrpAsgnId string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdGetExecute executes the request
	 * @return AccountGroupAssignment
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdGetRequest) (AccountGroupAssignment, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGet Returns a list of account group assignments for the given org
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGet(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetExecute executes the request
	 * @return AccountGroupAssignmentList
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetRequest) (AccountGroupAssignmentList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPost Create a new AccountGroupAssignment
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPostRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPost(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPostRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPostExecute executes the request
	 * @return AccountGroupAssignment
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPostExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPostRequest) (AccountGroupAssignment, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdDelete Delete an account group
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @param acctGrpId The id of account group
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdDeleteRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdDelete(ctx _context.Context, orgId string, acctGrpId string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdDeleteExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdGet Get account group by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @param acctGrpId The id of account group
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdGet(ctx _context.Context, orgId string, acctGrpId string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdGetExecute executes the request
	 * @return AccountGroup
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdGetRequest) (AccountGroup, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatch Update an account group
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @param acctGrpId The id of account group
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatchRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatch(ctx _context.Context, orgId string, acctGrpId string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatchRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatchExecute executes the request
	 * @return AccountGroup
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatchExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatchRequest) (AccountGroup, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGet Returns a list of account groups for the given org
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGet(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetExecute executes the request
	 * @return AccountGroupList
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetRequest) (AccountGroupList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPost Create a new AccountGroup
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPostRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPost(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPostRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPostExecute executes the request
	 * @return AccountGroup
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPostExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPostRequest) (AccountGroup, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGet Returns a list of consumed quota for an organization
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGet(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGetExecute executes the request
	 * @return ConsumedQuotaList
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGetRequest) (ConsumedQuotaList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGet Returns a list of resource quota objects
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGet(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetExecute executes the request
	 * @return ResourceQuotaList
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest) (ResourceQuotaList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPost Create a new resource quota
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPost(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostExecute executes the request
	 * @return ResourceQuota
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest) (ResourceQuota, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDelete Delete a resource quota
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @param quotaId The id of quota
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDelete(ctx _context.Context, orgId string, quotaId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGet Get a resource quota by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @param quotaId The id of quota
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGet(ctx _context.Context, orgId string, quotaId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetExecute executes the request
	 * @return ResourceQuota
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetRequest) (ResourceQuota, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatch Update a resource quota
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @param quotaId The id of quota
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatch(ctx _context.Context, orgId string, quotaId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchExecute executes the request
	 * @return ResourceQuota
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest) (ResourceQuota, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsPost Create a new organization
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1OrganizationsPostRequest
	 */
	ApiAccountsMgmtV1OrganizationsPost(ctx _context.Context) ApiApiAccountsMgmtV1OrganizationsPostRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsPostExecute executes the request
	 * @return Organization
	 */
	ApiAccountsMgmtV1OrganizationsPostExecute(r ApiApiAccountsMgmtV1OrganizationsPostRequest) (Organization, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1PlansGet Get all plans
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1PlansGetRequest
	 */
	ApiAccountsMgmtV1PlansGet(ctx _context.Context) ApiApiAccountsMgmtV1PlansGetRequest

	/*
	 * ApiAccountsMgmtV1PlansGetExecute executes the request
	 * @return PlanList
	 */
	ApiAccountsMgmtV1PlansGetExecute(r ApiApiAccountsMgmtV1PlansGetRequest) (PlanList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1PlansIdGet Get a plan by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1PlansIdGetRequest
	 */
	ApiAccountsMgmtV1PlansIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1PlansIdGetRequest

	/*
	 * ApiAccountsMgmtV1PlansIdGetExecute executes the request
	 * @return Plan
	 */
	ApiAccountsMgmtV1PlansIdGetExecute(r ApiApiAccountsMgmtV1PlansIdGetRequest) (Plan, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1PullSecretsExternalResourceIdDelete Delete a pull secret
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param externalResourceId The external resource id of record
	 * @return ApiApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteRequest
	 */
	ApiAccountsMgmtV1PullSecretsExternalResourceIdDelete(ctx _context.Context, externalResourceId string) ApiApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteExecute(r ApiApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1PullSecretsPost Return access token generated from registries in docker format
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1PullSecretsPostRequest
	 */
	ApiAccountsMgmtV1PullSecretsPost(ctx _context.Context) ApiApiAccountsMgmtV1PullSecretsPostRequest

	/*
	 * ApiAccountsMgmtV1PullSecretsPostExecute executes the request
	 * @return AccessTokenCfg
	 */
	ApiAccountsMgmtV1PullSecretsPostExecute(r ApiApiAccountsMgmtV1PullSecretsPostRequest) (AccessTokenCfg, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1QuotaCostGet Returns a summary of quota cost for the authenticated user
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1QuotaCostGetRequest
	 */
	ApiAccountsMgmtV1QuotaCostGet(ctx _context.Context) ApiApiAccountsMgmtV1QuotaCostGetRequest

	/*
	 * ApiAccountsMgmtV1QuotaCostGetExecute executes the request
	 * @return QuotaCostList
	 */
	ApiAccountsMgmtV1QuotaCostGetExecute(r ApiApiAccountsMgmtV1QuotaCostGetRequest) (QuotaCostList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1QuotaRulesGet Returns a list of UHC product Quota Rules
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1QuotaRulesGetRequest
	 */
	ApiAccountsMgmtV1QuotaRulesGet(ctx _context.Context) ApiApiAccountsMgmtV1QuotaRulesGetRequest

	/*
	 * ApiAccountsMgmtV1QuotaRulesGetExecute executes the request
	 * @return QuotaRulesList
	 */
	ApiAccountsMgmtV1QuotaRulesGetExecute(r ApiApiAccountsMgmtV1QuotaRulesGetRequest) (QuotaRulesList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1QuotasGet Returns a list of quotas
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1QuotasGetRequest
	 */
	ApiAccountsMgmtV1QuotasGet(ctx _context.Context) ApiApiAccountsMgmtV1QuotasGetRequest

	/*
	 * ApiAccountsMgmtV1QuotasGetExecute executes the request
	 * @return QuotaList
	 */
	ApiAccountsMgmtV1QuotasGetExecute(r ApiApiAccountsMgmtV1QuotasGetRequest) (QuotaList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1QuotasIdDelete Delete a quota
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1QuotasIdDeleteRequest
	 */
	ApiAccountsMgmtV1QuotasIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1QuotasIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1QuotasIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1QuotasIdDeleteExecute(r ApiApiAccountsMgmtV1QuotasIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1QuotasIdGet Get a quota
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1QuotasIdGetRequest
	 */
	ApiAccountsMgmtV1QuotasIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1QuotasIdGetRequest

	/*
	 * ApiAccountsMgmtV1QuotasIdGetExecute executes the request
	 * @return Quota
	 */
	ApiAccountsMgmtV1QuotasIdGetExecute(r ApiApiAccountsMgmtV1QuotasIdGetRequest) (Quota, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1QuotasIdPatch Update a quota
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1QuotasIdPatchRequest
	 */
	ApiAccountsMgmtV1QuotasIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1QuotasIdPatchRequest

	/*
	 * ApiAccountsMgmtV1QuotasIdPatchExecute executes the request
	 * @return Quota
	 */
	ApiAccountsMgmtV1QuotasIdPatchExecute(r ApiApiAccountsMgmtV1QuotasIdPatchRequest) (Quota, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1QuotasPost Create a new quota
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1QuotasPostRequest
	 */
	ApiAccountsMgmtV1QuotasPost(ctx _context.Context) ApiApiAccountsMgmtV1QuotasPostRequest

	/*
	 * ApiAccountsMgmtV1QuotasPostExecute executes the request
	 * @return Quota
	 */
	ApiAccountsMgmtV1QuotasPostExecute(r ApiApiAccountsMgmtV1QuotasPostRequest) (Quota, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RegistriesGet Returns a list of registries
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1RegistriesGetRequest
	 */
	ApiAccountsMgmtV1RegistriesGet(ctx _context.Context) ApiApiAccountsMgmtV1RegistriesGetRequest

	/*
	 * ApiAccountsMgmtV1RegistriesGetExecute executes the request
	 * @return RegistryList
	 */
	ApiAccountsMgmtV1RegistriesGetExecute(r ApiApiAccountsMgmtV1RegistriesGetRequest) (RegistryList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RegistriesIdGet Get an registry by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1RegistriesIdGetRequest
	 */
	ApiAccountsMgmtV1RegistriesIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1RegistriesIdGetRequest

	/*
	 * ApiAccountsMgmtV1RegistriesIdGetExecute executes the request
	 * @return Registry
	 */
	ApiAccountsMgmtV1RegistriesIdGetExecute(r ApiApiAccountsMgmtV1RegistriesIdGetRequest) (Registry, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsGet Method for ApiAccountsMgmtV1RegistryCredentialsGet
	 * List Registry Credentials
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1RegistryCredentialsGetRequest
	 */
	ApiAccountsMgmtV1RegistryCredentialsGet(ctx _context.Context) ApiApiAccountsMgmtV1RegistryCredentialsGetRequest

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsGetExecute executes the request
	 * @return RegistryCredentialList
	 */
	ApiAccountsMgmtV1RegistryCredentialsGetExecute(r ApiApiAccountsMgmtV1RegistryCredentialsGetRequest) (RegistryCredentialList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsIdDelete Delete a registry credential by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1RegistryCredentialsIdDeleteRequest
	 */
	ApiAccountsMgmtV1RegistryCredentialsIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1RegistryCredentialsIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1RegistryCredentialsIdDeleteExecute(r ApiApiAccountsMgmtV1RegistryCredentialsIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsIdGet Get a registry credentials by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1RegistryCredentialsIdGetRequest
	 */
	ApiAccountsMgmtV1RegistryCredentialsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1RegistryCredentialsIdGetRequest

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsIdGetExecute executes the request
	 * @return RegistryCredential
	 */
	ApiAccountsMgmtV1RegistryCredentialsIdGetExecute(r ApiApiAccountsMgmtV1RegistryCredentialsIdGetRequest) (RegistryCredential, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsIdPatch Update a registry credential
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest
	 */
	ApiAccountsMgmtV1RegistryCredentialsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsIdPatchExecute executes the request
	 * @return RegistryCredential
	 */
	ApiAccountsMgmtV1RegistryCredentialsIdPatchExecute(r ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest) (RegistryCredential, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsPost Request the creation of a registry credential
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1RegistryCredentialsPostRequest
	 */
	ApiAccountsMgmtV1RegistryCredentialsPost(ctx _context.Context) ApiApiAccountsMgmtV1RegistryCredentialsPostRequest

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsPostExecute executes the request
	 * @return RegistryCredential
	 */
	ApiAccountsMgmtV1RegistryCredentialsPostExecute(r ApiApiAccountsMgmtV1RegistryCredentialsPostRequest) (RegistryCredential, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ReservedResourcesGet Returns a list of reserved resources
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1ReservedResourcesGetRequest
	 */
	ApiAccountsMgmtV1ReservedResourcesGet(ctx _context.Context) ApiApiAccountsMgmtV1ReservedResourcesGetRequest

	/*
	 * ApiAccountsMgmtV1ReservedResourcesGetExecute executes the request
	 * @return ReservedResourceList
	 */
	ApiAccountsMgmtV1ReservedResourcesGetExecute(r ApiApiAccountsMgmtV1ReservedResourcesGetRequest) (ReservedResourceList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ResourceQuotaGet Returns a list of resource quota objects
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1ResourceQuotaGetRequest
	 */
	ApiAccountsMgmtV1ResourceQuotaGet(ctx _context.Context) ApiApiAccountsMgmtV1ResourceQuotaGetRequest

	/*
	 * ApiAccountsMgmtV1ResourceQuotaGetExecute executes the request
	 * @return ResourceQuotaList
	 */
	ApiAccountsMgmtV1ResourceQuotaGetExecute(r ApiApiAccountsMgmtV1ResourceQuotaGetRequest) (ResourceQuotaList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RoleBindingsGet Returns a list of role bindings
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1RoleBindingsGetRequest
	 */
	ApiAccountsMgmtV1RoleBindingsGet(ctx _context.Context) ApiApiAccountsMgmtV1RoleBindingsGetRequest

	/*
	 * ApiAccountsMgmtV1RoleBindingsGetExecute executes the request
	 * @return RoleBindingList
	 */
	ApiAccountsMgmtV1RoleBindingsGetExecute(r ApiApiAccountsMgmtV1RoleBindingsGetRequest) (RoleBindingList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RoleBindingsIdDelete Delete a role binding
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1RoleBindingsIdDeleteRequest
	 */
	ApiAccountsMgmtV1RoleBindingsIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1RoleBindingsIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1RoleBindingsIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1RoleBindingsIdDeleteExecute(r ApiApiAccountsMgmtV1RoleBindingsIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RoleBindingsIdGet Get a role binding
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1RoleBindingsIdGetRequest
	 */
	ApiAccountsMgmtV1RoleBindingsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1RoleBindingsIdGetRequest

	/*
	 * ApiAccountsMgmtV1RoleBindingsIdGetExecute executes the request
	 * @return RoleBinding
	 */
	ApiAccountsMgmtV1RoleBindingsIdGetExecute(r ApiApiAccountsMgmtV1RoleBindingsIdGetRequest) (RoleBinding, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RoleBindingsIdPatch Update a role binding
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest
	 */
	ApiAccountsMgmtV1RoleBindingsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest

	/*
	 * ApiAccountsMgmtV1RoleBindingsIdPatchExecute executes the request
	 * @return RoleBinding
	 */
	ApiAccountsMgmtV1RoleBindingsIdPatchExecute(r ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest) (RoleBinding, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RoleBindingsPost Create a new role binding
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1RoleBindingsPostRequest
	 */
	ApiAccountsMgmtV1RoleBindingsPost(ctx _context.Context) ApiApiAccountsMgmtV1RoleBindingsPostRequest

	/*
	 * ApiAccountsMgmtV1RoleBindingsPostExecute executes the request
	 * @return RoleBinding
	 */
	ApiAccountsMgmtV1RoleBindingsPostExecute(r ApiApiAccountsMgmtV1RoleBindingsPostRequest) (RoleBinding, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RolesGet Returns a list of roles
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1RolesGetRequest
	 */
	ApiAccountsMgmtV1RolesGet(ctx _context.Context) ApiApiAccountsMgmtV1RolesGetRequest

	/*
	 * ApiAccountsMgmtV1RolesGetExecute executes the request
	 * @return RoleList
	 */
	ApiAccountsMgmtV1RolesGetExecute(r ApiApiAccountsMgmtV1RolesGetRequest) (RoleList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RolesIdGet Get a role by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1RolesIdGetRequest
	 */
	ApiAccountsMgmtV1RolesIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1RolesIdGetRequest

	/*
	 * ApiAccountsMgmtV1RolesIdGetExecute executes the request
	 * @return Role
	 */
	ApiAccountsMgmtV1RolesIdGetExecute(r ApiApiAccountsMgmtV1RolesIdGetRequest) (Role, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SelfEntitlementProductPost Create or renew the entitlement to support a product for the user's organization.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param product The product for self_entitlement. The supported products are [rosa].
	 * @return ApiApiAccountsMgmtV1SelfEntitlementProductPostRequest
	 */
	ApiAccountsMgmtV1SelfEntitlementProductPost(ctx _context.Context, product string) ApiApiAccountsMgmtV1SelfEntitlementProductPostRequest

	/*
	 * ApiAccountsMgmtV1SelfEntitlementProductPostExecute executes the request
	 * @return SelfEntitlementStatus
	 */
	ApiAccountsMgmtV1SelfEntitlementProductPostExecute(r ApiApiAccountsMgmtV1SelfEntitlementProductPostRequest) (SelfEntitlementStatus, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SkuRulesGet Returns a list of UHC product SKU Rules
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1SkuRulesGetRequest
	 */
	ApiAccountsMgmtV1SkuRulesGet(ctx _context.Context) ApiApiAccountsMgmtV1SkuRulesGetRequest

	/*
	 * ApiAccountsMgmtV1SkuRulesGetExecute executes the request
	 * @return SkuRulesList
	 */
	ApiAccountsMgmtV1SkuRulesGetExecute(r ApiApiAccountsMgmtV1SkuRulesGetRequest) (SkuRulesList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SkuRulesIdDelete Delete a sku rule
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SkuRulesIdDeleteRequest
	 */
	ApiAccountsMgmtV1SkuRulesIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1SkuRulesIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1SkuRulesIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1SkuRulesIdDeleteExecute(r ApiApiAccountsMgmtV1SkuRulesIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SkuRulesIdGet Get a sku rules by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SkuRulesIdGetRequest
	 */
	ApiAccountsMgmtV1SkuRulesIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SkuRulesIdGetRequest

	/*
	 * ApiAccountsMgmtV1SkuRulesIdGetExecute executes the request
	 * @return SkuRules
	 */
	ApiAccountsMgmtV1SkuRulesIdGetExecute(r ApiApiAccountsMgmtV1SkuRulesIdGetRequest) (SkuRules, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SkuRulesIdPatch Update a sku rule
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SkuRulesIdPatchRequest
	 */
	ApiAccountsMgmtV1SkuRulesIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1SkuRulesIdPatchRequest

	/*
	 * ApiAccountsMgmtV1SkuRulesIdPatchExecute executes the request
	 * @return SkuRules
	 */
	ApiAccountsMgmtV1SkuRulesIdPatchExecute(r ApiApiAccountsMgmtV1SkuRulesIdPatchRequest) (SkuRules, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SkuRulesPost Create a new sku rule
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1SkuRulesPostRequest
	 */
	ApiAccountsMgmtV1SkuRulesPost(ctx _context.Context) ApiApiAccountsMgmtV1SkuRulesPostRequest

	/*
	 * ApiAccountsMgmtV1SkuRulesPostExecute executes the request
	 * @return SkuRules
	 */
	ApiAccountsMgmtV1SkuRulesPostExecute(r ApiApiAccountsMgmtV1SkuRulesPostRequest) (SkuRules, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SkusGet Returns a list of UHC product SKUs
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1SkusGetRequest
	 */
	ApiAccountsMgmtV1SkusGet(ctx _context.Context) ApiApiAccountsMgmtV1SkusGetRequest

	/*
	 * ApiAccountsMgmtV1SkusGetExecute executes the request
	 * @return SkuList
	 */
	ApiAccountsMgmtV1SkusGetExecute(r ApiApiAccountsMgmtV1SkusGetRequest) (SkuList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SkusIdGet Get a sku by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SkusIdGetRequest
	 */
	ApiAccountsMgmtV1SkusIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SkusIdGetRequest

	/*
	 * ApiAccountsMgmtV1SkusIdGetExecute executes the request
	 * @return SKU
	 */
	ApiAccountsMgmtV1SkusIdGetExecute(r ApiApiAccountsMgmtV1SkusIdGetRequest) (SKU, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsGet Returns a list of subscriptions
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1SubscriptionsGetRequest
	 */
	ApiAccountsMgmtV1SubscriptionsGet(ctx _context.Context) ApiApiAccountsMgmtV1SubscriptionsGetRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsGetExecute executes the request
	 * @return SubscriptionList
	 */
	ApiAccountsMgmtV1SubscriptionsGetExecute(r ApiApiAccountsMgmtV1SubscriptionsGetRequest) (SubscriptionList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdDelete Deletes a subscription by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdDeleteRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1SubscriptionsIdDeleteExecute(r ApiApiAccountsMgmtV1SubscriptionsIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdGet Get a subscription by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdGetRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdGetRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdGetExecute executes the request
	 * @return Subscription
	 */
	ApiAccountsMgmtV1SubscriptionsIdGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdGetRequest) (Subscription, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsGet Returns a list of labels
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsGetExecute executes the request
	 * @return LabelList
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest) (LabelList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsKeyDelete Delete a label
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param key The key of the label
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsKeyDelete(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsKeyGet Get subscription labels by label key
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param key The key of the label
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsKeyGet(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetExecute executes the request
	 * @return Label
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetRequest) (Label, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatch Create a new label or update an existing label
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param key The key of the label
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatch(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchExecute executes the request
	 * @return Label
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest) (Label, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsPost Create a new label or update an existing label
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsPostExecute executes the request
	 * @return Label
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsPostExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest) (Label, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGet Get subscription's metrics by metric name
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param metricName The name of the metric
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGetRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGet(ctx _context.Context, id string, metricName string) ApiApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGetRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGetExecute executes the request
	 * @return SubscriptionMetricList
	 */
	ApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGetRequest) (SubscriptionMetricList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdNotifyPost Notify the owner of a subscription
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdNotifyPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdNotifyPostExecute executes the request
	 */
	ApiAccountsMgmtV1SubscriptionsIdNotifyPostExecute(r ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdPatch Update a subscription
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdPatchExecute executes the request
	 * @return Subscription
	 */
	ApiAccountsMgmtV1SubscriptionsIdPatchExecute(r ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest) (Subscription, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdReservedResourcesGet Returns a list of reserved resources
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdReservedResourcesGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetExecute executes the request
	 * @return ReservedResourceList
	 */
	ApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest) (ReservedResourceList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdSupportCasesGet Returns a list of open support creates opened against the external cluster id of this subscrption
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdSupportCasesGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdSupportCasesGetExecute executes the request
	 */
	ApiAccountsMgmtV1SubscriptionsIdSupportCasesGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsPost Create a new subscription
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1SubscriptionsPostRequest
	 */
	ApiAccountsMgmtV1SubscriptionsPost(ctx _context.Context) ApiApiAccountsMgmtV1SubscriptionsPostRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsPostExecute executes the request
	 * @return Subscription
	 */
	ApiAccountsMgmtV1SubscriptionsPostExecute(r ApiApiAccountsMgmtV1SubscriptionsPostRequest) (Subscription, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDelete Deletes a notification contact by subscription and account id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param subId The id of subscription
	 * @param accountId The id of account
	 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteRequest
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDelete(ctx _context.Context, subId string, accountId string) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGet Returns a list of notification contacts for the given subscription
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param subId The id of subscription
	 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGet(ctx _context.Context, subId string) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetExecute executes the request
	 * @return AccountList
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest) (AccountList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPost Add an account as a notification contact to this subscription
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param subId The id of subscription
	 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPost(ctx _context.Context, subId string) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostExecute executes the request
	 * @return Account
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest) (Account, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdDelete Delete reserved resources by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param subId The id of subscription
	 * @param reservedResourceId The id of reserved resource
	 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdDeleteRequest
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdDelete(ctx _context.Context, subId string, reservedResourceId string) ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdDeleteExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGet Get reserved resources by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param subId The id of subscription
	 * @param reservedResourceId The id of reserved resource
	 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetRequest
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGet(ctx _context.Context, subId string, reservedResourceId string) ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetExecute executes the request
	 * @return ReservedResource
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetRequest) (ReservedResource, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatch Update a reserved resource
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param subId The id of subscription
	 * @param reservedResourceId The id of reserved resource
	 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatchRequest
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatch(ctx _context.Context, subId string, reservedResourceId string) ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatchRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatchExecute executes the request
	 * @return ReservedResource
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatchExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatchRequest) (ReservedResource, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGet Get subscription role bindings
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param subId The id of subscription
	 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetRequest
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGet(ctx _context.Context, subId string) ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetExecute executes the request
	 * @return SubscriptionRoleBindingList
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetRequest) (SubscriptionRoleBindingList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdDelete Delete a subscription role binding
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param subId The id of subscription
	 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdDeleteRequest
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdDelete(ctx _context.Context, id string, subId string) ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdDeleteExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdGet Get a Subscription Role Binding by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param subId The id of subscription
	 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdGetRequest
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdGet(ctx _context.Context, id string, subId string) ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdGetRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdGetExecute executes the request
	 * @return SubscriptionRoleBinding
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdGetExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdGetRequest) (SubscriptionRoleBinding, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPost Create a new subscription role binding
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param subId The id of subscription
	 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPostRequest
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPost(ctx _context.Context, subId string) ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPostRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPostExecute executes the request
	 * @return SubscriptionRoleBinding
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPostExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPostRequest) (SubscriptionRoleBinding, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SupportCasesCaseIdDelete Delete a support case
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param caseId The id of a support case
	 * @return ApiApiAccountsMgmtV1SupportCasesCaseIdDeleteRequest
	 */
	ApiAccountsMgmtV1SupportCasesCaseIdDelete(ctx _context.Context, caseId string) ApiApiAccountsMgmtV1SupportCasesCaseIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1SupportCasesCaseIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1SupportCasesCaseIdDeleteExecute(r ApiApiAccountsMgmtV1SupportCasesCaseIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SupportCasesPost create a support case for the subscription
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1SupportCasesPostRequest
	 */
	ApiAccountsMgmtV1SupportCasesPost(ctx _context.Context) ApiApiAccountsMgmtV1SupportCasesPostRequest

	/*
	 * ApiAccountsMgmtV1SupportCasesPostExecute executes the request
	 * @return SupportCasesCreatedResponse
	 */
	ApiAccountsMgmtV1SupportCasesPostExecute(r ApiApiAccountsMgmtV1SupportCasesPostRequest) (SupportCasesCreatedResponse, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1TokenAuthorizationPost Finds the account owner of the provided token
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1TokenAuthorizationPostRequest
	 */
	ApiAccountsMgmtV1TokenAuthorizationPost(ctx _context.Context) ApiApiAccountsMgmtV1TokenAuthorizationPostRequest

	/*
	 * ApiAccountsMgmtV1TokenAuthorizationPostExecute executes the request
	 * @return TokenAuthorizationResponse
	 */
	ApiAccountsMgmtV1TokenAuthorizationPostExecute(r ApiApiAccountsMgmtV1TokenAuthorizationPostRequest) (TokenAuthorizationResponse, *_nethttp.Response, error)

	/*
	 * ApiAuthorizationsV1AccessReviewPost Review an account's access to perform an action on a particular resource or resource type
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAuthorizationsV1AccessReviewPostRequest
	 */
	ApiAuthorizationsV1AccessReviewPost(ctx _context.Context) ApiApiAuthorizationsV1AccessReviewPostRequest

	/*
	 * ApiAuthorizationsV1AccessReviewPostExecute executes the request
	 * @return AccessReviewResponse
	 */
	ApiAuthorizationsV1AccessReviewPostExecute(r ApiApiAuthorizationsV1AccessReviewPostRequest) (AccessReviewResponse, *_nethttp.Response, error)

	/*
	 * ApiAuthorizationsV1CapabilityReviewPost Review an account's capabilities
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAuthorizationsV1CapabilityReviewPostRequest
	 */
	ApiAuthorizationsV1CapabilityReviewPost(ctx _context.Context) ApiApiAuthorizationsV1CapabilityReviewPostRequest

	/*
	 * ApiAuthorizationsV1CapabilityReviewPostExecute executes the request
	 * @return CapabilityReview
	 */
	ApiAuthorizationsV1CapabilityReviewPostExecute(r ApiApiAuthorizationsV1CapabilityReviewPostRequest) (CapabilityReview, *_nethttp.Response, error)

	/*
	 * ApiAuthorizationsV1ExportControlReviewPost Determine whether a user is restricted from downloading Red Hat software based on export control compliance. 
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAuthorizationsV1ExportControlReviewPostRequest
	 */
	ApiAuthorizationsV1ExportControlReviewPost(ctx _context.Context) ApiApiAuthorizationsV1ExportControlReviewPostRequest

	/*
	 * ApiAuthorizationsV1ExportControlReviewPostExecute executes the request
	 * @return ExportControlReview
	 */
	ApiAuthorizationsV1ExportControlReviewPostExecute(r ApiApiAuthorizationsV1ExportControlReviewPostRequest) (ExportControlReview, *_nethttp.Response, error)

	/*
	 * ApiAuthorizationsV1FeatureReviewPost Review feature to perform an action on it such as toggle a feature on/off
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAuthorizationsV1FeatureReviewPostRequest
	 */
	ApiAuthorizationsV1FeatureReviewPost(ctx _context.Context) ApiApiAuthorizationsV1FeatureReviewPostRequest

	/*
	 * ApiAuthorizationsV1FeatureReviewPostExecute executes the request
	 * @return FeatureReviewResponse
	 */
	ApiAuthorizationsV1FeatureReviewPostExecute(r ApiApiAuthorizationsV1FeatureReviewPostRequest) (FeatureReviewResponse, *_nethttp.Response, error)

	/*
	 * ApiAuthorizationsV1ResourceReviewPost Obtain resource ids for resources an account may perform the specified action upon. Resource ids returned as [\"*\"] is shorthand for all ids.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAuthorizationsV1ResourceReviewPostRequest
	 */
	ApiAuthorizationsV1ResourceReviewPost(ctx _context.Context) ApiApiAuthorizationsV1ResourceReviewPostRequest

	/*
	 * ApiAuthorizationsV1ResourceReviewPostExecute executes the request
	 * @return ResourceReview
	 */
	ApiAuthorizationsV1ResourceReviewPostExecute(r ApiApiAuthorizationsV1ResourceReviewPostRequest) (ResourceReview, *_nethttp.Response, error)

	/*
	 * ApiAuthorizationsV1SelfAccessReviewPost Review your ability to perform an action on a particular resource or resource type
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAuthorizationsV1SelfAccessReviewPostRequest
	 */
	ApiAuthorizationsV1SelfAccessReviewPost(ctx _context.Context) ApiApiAuthorizationsV1SelfAccessReviewPostRequest

	/*
	 * ApiAuthorizationsV1SelfAccessReviewPostExecute executes the request
	 * @return AccessReviewResponse
	 */
	ApiAuthorizationsV1SelfAccessReviewPostExecute(r ApiApiAuthorizationsV1SelfAccessReviewPostRequest) (AccessReviewResponse, *_nethttp.Response, error)

	/*
	 * ApiAuthorizationsV1SelfFeatureReviewPost Review your ability to toggle a feature
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAuthorizationsV1SelfFeatureReviewPostRequest
	 */
	ApiAuthorizationsV1SelfFeatureReviewPost(ctx _context.Context) ApiApiAuthorizationsV1SelfFeatureReviewPostRequest

	/*
	 * ApiAuthorizationsV1SelfFeatureReviewPostExecute executes the request
	 * @return FeatureReviewResponse
	 */
	ApiAuthorizationsV1SelfFeatureReviewPostExecute(r ApiApiAuthorizationsV1SelfFeatureReviewPostRequest) (FeatureReviewResponse, *_nethttp.Response, error)

	/*
	 * ApiAuthorizationsV1SelfResourceReviewPost Obtain resource ids for resources you may perform the specified action upon. Resource ids returned as [\"*\"] is shorthand for all ids.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAuthorizationsV1SelfResourceReviewPostRequest
	 */
	ApiAuthorizationsV1SelfResourceReviewPost(ctx _context.Context) ApiApiAuthorizationsV1SelfResourceReviewPostRequest

	/*
	 * ApiAuthorizationsV1SelfResourceReviewPostExecute executes the request
	 * @return SelfResourceReview
	 */
	ApiAuthorizationsV1SelfResourceReviewPostExecute(r ApiApiAuthorizationsV1SelfResourceReviewPostRequest) (SelfResourceReview, *_nethttp.Response, error)

	/*
	 * ApiAuthorizationsV1TermsReviewPost Review an account's status of Terms
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAuthorizationsV1TermsReviewPostRequest
	 */
	ApiAuthorizationsV1TermsReviewPost(ctx _context.Context) ApiApiAuthorizationsV1TermsReviewPostRequest

	/*
	 * ApiAuthorizationsV1TermsReviewPostExecute executes the request
	 * @return TermsReviewResponse
	 */
	ApiAuthorizationsV1TermsReviewPostExecute(r ApiApiAuthorizationsV1TermsReviewPostRequest) (TermsReviewResponse, *_nethttp.Response, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiApiAccountsMgmtV1AccountsGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	page *int32
	size *int32
	search *string
	orderBy *string
	fields *string
	fetchLabels *bool
	fetchCapabilities *bool
}

func (r ApiApiAccountsMgmtV1AccountsGetRequest) Page(page int32) ApiApiAccountsMgmtV1AccountsGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1AccountsGetRequest) Size(size int32) ApiApiAccountsMgmtV1AccountsGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1AccountsGetRequest) Search(search string) ApiApiAccountsMgmtV1AccountsGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1AccountsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1AccountsGetRequest {
	r.orderBy = &orderBy
	return r
}
func (r ApiApiAccountsMgmtV1AccountsGetRequest) Fields(fields string) ApiApiAccountsMgmtV1AccountsGetRequest {
	r.fields = &fields
	return r
}
func (r ApiApiAccountsMgmtV1AccountsGetRequest) FetchLabels(fetchLabels bool) ApiApiAccountsMgmtV1AccountsGetRequest {
	r.fetchLabels = &fetchLabels
	return r
}
func (r ApiApiAccountsMgmtV1AccountsGetRequest) FetchCapabilities(fetchCapabilities bool) ApiApiAccountsMgmtV1AccountsGetRequest {
	r.fetchCapabilities = &fetchCapabilities
	return r
}

func (r ApiApiAccountsMgmtV1AccountsGetRequest) Execute() (AccountList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1AccountsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1AccountsGet Returns a list of accounts
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1AccountsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsGet(ctx _context.Context) ApiApiAccountsMgmtV1AccountsGetRequest {
	return ApiApiAccountsMgmtV1AccountsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return AccountList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsGetExecute(r ApiApiAccountsMgmtV1AccountsGetRequest) (AccountList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccountList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1AccountsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	if r.fetchLabels != nil {
		localVarQueryParams.Add("fetchLabels", parameterToString(*r.fetchLabels, ""))
	}
	if r.fetchCapabilities != nil {
		localVarQueryParams.Add("fetchCapabilities", parameterToString(*r.fetchCapabilities, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1AccountsIdGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	fetchLabels *bool
	fetchCapabilities *bool
	fetchRhit *bool
}

func (r ApiApiAccountsMgmtV1AccountsIdGetRequest) FetchLabels(fetchLabels bool) ApiApiAccountsMgmtV1AccountsIdGetRequest {
	r.fetchLabels = &fetchLabels
	return r
}
func (r ApiApiAccountsMgmtV1AccountsIdGetRequest) FetchCapabilities(fetchCapabilities bool) ApiApiAccountsMgmtV1AccountsIdGetRequest {
	r.fetchCapabilities = &fetchCapabilities
	return r
}
func (r ApiApiAccountsMgmtV1AccountsIdGetRequest) FetchRhit(fetchRhit bool) ApiApiAccountsMgmtV1AccountsIdGetRequest {
	r.fetchRhit = &fetchRhit
	return r
}

func (r ApiApiAccountsMgmtV1AccountsIdGetRequest) Execute() (Account, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1AccountsIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1AccountsIdGet Get an account by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1AccountsIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1AccountsIdGetRequest {
	return ApiApiAccountsMgmtV1AccountsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return Account
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdGetExecute(r ApiApiAccountsMgmtV1AccountsIdGetRequest) (Account, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1AccountsIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/accounts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fetchLabels != nil {
		localVarQueryParams.Add("fetchLabels", parameterToString(*r.fetchLabels, ""))
	}
	if r.fetchCapabilities != nil {
		localVarQueryParams.Add("fetchCapabilities", parameterToString(*r.fetchCapabilities, ""))
	}
	if r.fetchRhit != nil {
		localVarQueryParams.Add("fetchRhit", parameterToString(*r.fetchRhit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	page *int32
	size *int32
	search *string
	orderBy *string
}

func (r ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest) Page(page int32) ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest) Size(size int32) ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest) Search(search string) ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest) Execute() (LabelList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1AccountsIdLabelsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1AccountsIdLabelsGet Returns a list of labels
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest {
	return ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return LabelList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsGetExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest) (LabelList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LabelList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1AccountsIdLabelsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/accounts/{id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1AccountsIdLabelsKeyDeleteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	key string
}


func (r ApiApiAccountsMgmtV1AccountsIdLabelsKeyDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1AccountsIdLabelsKeyDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1AccountsIdLabelsKeyDelete Delete a label
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param key The key of the label
 * @return ApiApiAccountsMgmtV1AccountsIdLabelsKeyDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsKeyDelete(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1AccountsIdLabelsKeyDeleteRequest {
	return ApiApiAccountsMgmtV1AccountsIdLabelsKeyDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		key: key,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsKeyDeleteExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsKeyDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1AccountsIdLabelsKeyDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/accounts/{id}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1AccountsIdLabelsKeyGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	key string
}


func (r ApiApiAccountsMgmtV1AccountsIdLabelsKeyGetRequest) Execute() (Label, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1AccountsIdLabelsKeyGetExecute(r)
}

/*
 * ApiAccountsMgmtV1AccountsIdLabelsKeyGet Get subscription labels by label key
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param key The key of the label
 * @return ApiApiAccountsMgmtV1AccountsIdLabelsKeyGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsKeyGet(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1AccountsIdLabelsKeyGetRequest {
	return ApiApiAccountsMgmtV1AccountsIdLabelsKeyGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		key: key,
	}
}

/*
 * Execute executes the request
 * @return Label
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsKeyGetExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsKeyGetRequest) (Label, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Label
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1AccountsIdLabelsKeyGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/accounts/{id}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	key string
	label *Label
}

func (r ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest) Label(label Label) ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest {
	r.label = &label
	return r
}

func (r ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest) Execute() (Label, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1AccountsIdLabelsKeyPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1AccountsIdLabelsKeyPatch Create a new label or update an existing label
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param key The key of the label
 * @return ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsKeyPatch(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest {
	return ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		key: key,
	}
}

/*
 * Execute executes the request
 * @return Label
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsKeyPatchExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest) (Label, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Label
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1AccountsIdLabelsKeyPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/accounts/{id}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.label == nil {
		return localVarReturnValue, nil, reportError("label is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.label
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	label *Label
}

func (r ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest) Label(label Label) ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest {
	r.label = &label
	return r
}

func (r ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest) Execute() (Label, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1AccountsIdLabelsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1AccountsIdLabelsPost Create a new label or update an existing label
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest {
	return ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return Label
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsPostExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest) (Label, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Label
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1AccountsIdLabelsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/accounts/{id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.label == nil {
		return localVarReturnValue, nil, reportError("label is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.label
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1AccountsIdPatchRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	accountPatchRequest *AccountPatchRequest
}

func (r ApiApiAccountsMgmtV1AccountsIdPatchRequest) AccountPatchRequest(accountPatchRequest AccountPatchRequest) ApiApiAccountsMgmtV1AccountsIdPatchRequest {
	r.accountPatchRequest = &accountPatchRequest
	return r
}

func (r ApiApiAccountsMgmtV1AccountsIdPatchRequest) Execute() (Account, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1AccountsIdPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1AccountsIdPatch Update an account
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1AccountsIdPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1AccountsIdPatchRequest {
	return ApiApiAccountsMgmtV1AccountsIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return Account
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdPatchExecute(r ApiApiAccountsMgmtV1AccountsIdPatchRequest) (Account, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1AccountsIdPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/accounts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.accountPatchRequest == nil {
		return localVarReturnValue, nil, reportError("accountPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1AccountsPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	account *Account
	dryRun *bool
}

func (r ApiApiAccountsMgmtV1AccountsPostRequest) Account(account Account) ApiApiAccountsMgmtV1AccountsPostRequest {
	r.account = &account
	return r
}
func (r ApiApiAccountsMgmtV1AccountsPostRequest) DryRun(dryRun bool) ApiApiAccountsMgmtV1AccountsPostRequest {
	r.dryRun = &dryRun
	return r
}

func (r ApiApiAccountsMgmtV1AccountsPostRequest) Execute() (Account, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1AccountsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1AccountsPost Create a new account
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1AccountsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsPost(ctx _context.Context) ApiApiAccountsMgmtV1AccountsPostRequest {
	return ApiApiAccountsMgmtV1AccountsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return Account
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsPostExecute(r ApiApiAccountsMgmtV1AccountsPostRequest) (Account, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1AccountsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.account == nil {
		return localVarReturnValue, nil, reportError("account is required and must be specified")
	}

	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.account
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1CertificatesPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	certificatesRequest *CertificatesRequest
}

func (r ApiApiAccountsMgmtV1CertificatesPostRequest) CertificatesRequest(certificatesRequest CertificatesRequest) ApiApiAccountsMgmtV1CertificatesPostRequest {
	r.certificatesRequest = &certificatesRequest
	return r
}

func (r ApiApiAccountsMgmtV1CertificatesPostRequest) Execute() (Certificate, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1CertificatesPostExecute(r)
}

/*
 * ApiAccountsMgmtV1CertificatesPost Fetch certificates of a particular type
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1CertificatesPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1CertificatesPost(ctx _context.Context) ApiApiAccountsMgmtV1CertificatesPostRequest {
	return ApiApiAccountsMgmtV1CertificatesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return Certificate
 */
func (a *DefaultApiService) ApiAccountsMgmtV1CertificatesPostExecute(r ApiApiAccountsMgmtV1CertificatesPostRequest) (Certificate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Certificate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1CertificatesPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/certificates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.certificatesRequest == nil {
		return localVarReturnValue, nil, reportError("certificatesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.certificatesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["AccessToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1CloudResourcesGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	page *int32
	size *int32
	search *string
}

func (r ApiApiAccountsMgmtV1CloudResourcesGetRequest) Page(page int32) ApiApiAccountsMgmtV1CloudResourcesGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1CloudResourcesGetRequest) Size(size int32) ApiApiAccountsMgmtV1CloudResourcesGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1CloudResourcesGetRequest) Search(search string) ApiApiAccountsMgmtV1CloudResourcesGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1CloudResourcesGetRequest) Execute() (CloudResourceList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1CloudResourcesGetExecute(r)
}

/*
 * ApiAccountsMgmtV1CloudResourcesGet Returns a list of cloud resources
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1CloudResourcesGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1CloudResourcesGet(ctx _context.Context) ApiApiAccountsMgmtV1CloudResourcesGetRequest {
	return ApiApiAccountsMgmtV1CloudResourcesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return CloudResourceList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1CloudResourcesGetExecute(r ApiApiAccountsMgmtV1CloudResourcesGetRequest) (CloudResourceList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CloudResourceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1CloudResourcesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/cloud_resources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1CloudResourcesIdDeleteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
}


func (r ApiApiAccountsMgmtV1CloudResourcesIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1CloudResourcesIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1CloudResourcesIdDelete Delete a cloud resource
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1CloudResourcesIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1CloudResourcesIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1CloudResourcesIdDeleteRequest {
	return ApiApiAccountsMgmtV1CloudResourcesIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1CloudResourcesIdDeleteExecute(r ApiApiAccountsMgmtV1CloudResourcesIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1CloudResourcesIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/cloud_resources/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1CloudResourcesIdGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
}


func (r ApiApiAccountsMgmtV1CloudResourcesIdGetRequest) Execute() (CloudResource, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1CloudResourcesIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1CloudResourcesIdGet Get a cloud resource
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1CloudResourcesIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1CloudResourcesIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1CloudResourcesIdGetRequest {
	return ApiApiAccountsMgmtV1CloudResourcesIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return CloudResource
 */
func (a *DefaultApiService) ApiAccountsMgmtV1CloudResourcesIdGetExecute(r ApiApiAccountsMgmtV1CloudResourcesIdGetRequest) (CloudResource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CloudResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1CloudResourcesIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/cloud_resources/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1CloudResourcesIdPatchRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	cloudResource *CloudResource
}

func (r ApiApiAccountsMgmtV1CloudResourcesIdPatchRequest) CloudResource(cloudResource CloudResource) ApiApiAccountsMgmtV1CloudResourcesIdPatchRequest {
	r.cloudResource = &cloudResource
	return r
}

func (r ApiApiAccountsMgmtV1CloudResourcesIdPatchRequest) Execute() (CloudResource, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1CloudResourcesIdPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1CloudResourcesIdPatch Update a cloud resource
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1CloudResourcesIdPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1CloudResourcesIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1CloudResourcesIdPatchRequest {
	return ApiApiAccountsMgmtV1CloudResourcesIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return CloudResource
 */
func (a *DefaultApiService) ApiAccountsMgmtV1CloudResourcesIdPatchExecute(r ApiApiAccountsMgmtV1CloudResourcesIdPatchRequest) (CloudResource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CloudResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1CloudResourcesIdPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/cloud_resources/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.cloudResource == nil {
		return localVarReturnValue, nil, reportError("cloudResource is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cloudResource
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1CloudResourcesPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	cloudResource *CloudResource
}

func (r ApiApiAccountsMgmtV1CloudResourcesPostRequest) CloudResource(cloudResource CloudResource) ApiApiAccountsMgmtV1CloudResourcesPostRequest {
	r.cloudResource = &cloudResource
	return r
}

func (r ApiApiAccountsMgmtV1CloudResourcesPostRequest) Execute() (CloudResource, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1CloudResourcesPostExecute(r)
}

/*
 * ApiAccountsMgmtV1CloudResourcesPost Create a new cloud resource
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1CloudResourcesPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1CloudResourcesPost(ctx _context.Context) ApiApiAccountsMgmtV1CloudResourcesPostRequest {
	return ApiApiAccountsMgmtV1CloudResourcesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return CloudResource
 */
func (a *DefaultApiService) ApiAccountsMgmtV1CloudResourcesPostExecute(r ApiApiAccountsMgmtV1CloudResourcesPostRequest) (CloudResource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CloudResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1CloudResourcesPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/cloud_resources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.cloudResource == nil {
		return localVarReturnValue, nil, reportError("cloudResource is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cloudResource
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	clusterAuthorizationRequest *ClusterAuthorizationRequest
}

func (r ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest) ClusterAuthorizationRequest(clusterAuthorizationRequest ClusterAuthorizationRequest) ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest {
	r.clusterAuthorizationRequest = &clusterAuthorizationRequest
	return r
}

func (r ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest) Execute() (ClusterAuthorizationResponse, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ClusterAuthorizationsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1ClusterAuthorizationsPost Authorizes new cluster creation against an exsiting RH Subscription.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ClusterAuthorizationsPost(ctx _context.Context) ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest {
	return ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ClusterAuthorizationResponse
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ClusterAuthorizationsPostExecute(r ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest) (ClusterAuthorizationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClusterAuthorizationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ClusterAuthorizationsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/cluster_authorizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.clusterAuthorizationRequest == nil {
		return localVarReturnValue, nil, reportError("clusterAuthorizationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clusterAuthorizationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	clusterRegistrationRequest *ClusterRegistrationRequest
}

func (r ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest) ClusterRegistrationRequest(clusterRegistrationRequest ClusterRegistrationRequest) ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest {
	r.clusterRegistrationRequest = &clusterRegistrationRequest
	return r
}

func (r ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest) Execute() (ClusterRegistrationResponse, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ClusterRegistrationsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1ClusterRegistrationsPost Finds or creates a cluster registration with a registy credential token and cluster ID
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ClusterRegistrationsPost(ctx _context.Context) ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest {
	return ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ClusterRegistrationResponse
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ClusterRegistrationsPostExecute(r ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest) (ClusterRegistrationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClusterRegistrationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ClusterRegistrationsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/cluster_registrations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.clusterRegistrationRequest == nil {
		return localVarReturnValue, nil, reportError("clusterRegistrationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clusterRegistrationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ClusterTransfersGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	page *int32
	size *int32
	search *string
	orderBy *string
}

func (r ApiApiAccountsMgmtV1ClusterTransfersGetRequest) Page(page int32) ApiApiAccountsMgmtV1ClusterTransfersGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1ClusterTransfersGetRequest) Size(size int32) ApiApiAccountsMgmtV1ClusterTransfersGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1ClusterTransfersGetRequest) Search(search string) ApiApiAccountsMgmtV1ClusterTransfersGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1ClusterTransfersGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1ClusterTransfersGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1ClusterTransfersGetRequest) Execute() (ClusterTransferList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ClusterTransfersGetExecute(r)
}

/*
 * ApiAccountsMgmtV1ClusterTransfersGet List cluster transfers - returns either an empty result set or a valid ClusterTransfer instance that is within a valid transfer window.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1ClusterTransfersGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ClusterTransfersGet(ctx _context.Context) ApiApiAccountsMgmtV1ClusterTransfersGetRequest {
	return ApiApiAccountsMgmtV1ClusterTransfersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ClusterTransferList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ClusterTransfersGetExecute(r ApiApiAccountsMgmtV1ClusterTransfersGetRequest) (ClusterTransferList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClusterTransferList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ClusterTransfersGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/cluster_transfers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["AccessToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ClusterTransfersIdPatchRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	clusterTransferPatchRequest *ClusterTransferPatchRequest
}

func (r ApiApiAccountsMgmtV1ClusterTransfersIdPatchRequest) ClusterTransferPatchRequest(clusterTransferPatchRequest ClusterTransferPatchRequest) ApiApiAccountsMgmtV1ClusterTransfersIdPatchRequest {
	r.clusterTransferPatchRequest = &clusterTransferPatchRequest
	return r
}

func (r ApiApiAccountsMgmtV1ClusterTransfersIdPatchRequest) Execute() (ClusterTransfer, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ClusterTransfersIdPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1ClusterTransfersIdPatch Update specific cluster transfer
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1ClusterTransfersIdPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ClusterTransfersIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1ClusterTransfersIdPatchRequest {
	return ApiApiAccountsMgmtV1ClusterTransfersIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return ClusterTransfer
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ClusterTransfersIdPatchExecute(r ApiApiAccountsMgmtV1ClusterTransfersIdPatchRequest) (ClusterTransfer, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClusterTransfer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ClusterTransfersIdPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/cluster_transfers/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.clusterTransferPatchRequest == nil {
		return localVarReturnValue, nil, reportError("clusterTransferPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clusterTransferPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ClusterTransfersPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	clusterTransferRequest *ClusterTransferRequest
}

func (r ApiApiAccountsMgmtV1ClusterTransfersPostRequest) ClusterTransferRequest(clusterTransferRequest ClusterTransferRequest) ApiApiAccountsMgmtV1ClusterTransfersPostRequest {
	r.clusterTransferRequest = &clusterTransferRequest
	return r
}

func (r ApiApiAccountsMgmtV1ClusterTransfersPostRequest) Execute() (ClusterTransfer, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ClusterTransfersPostExecute(r)
}

/*
 * ApiAccountsMgmtV1ClusterTransfersPost Initiate cluster transfer.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1ClusterTransfersPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ClusterTransfersPost(ctx _context.Context) ApiApiAccountsMgmtV1ClusterTransfersPostRequest {
	return ApiApiAccountsMgmtV1ClusterTransfersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ClusterTransfer
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ClusterTransfersPostExecute(r ApiApiAccountsMgmtV1ClusterTransfersPostRequest) (ClusterTransfer, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClusterTransfer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ClusterTransfersPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/cluster_transfers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.clusterTransferRequest == nil {
		return localVarReturnValue, nil, reportError("clusterTransferRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clusterTransferRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ConfigSkusGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	page *int32
	size *int32
	search *string
}

func (r ApiApiAccountsMgmtV1ConfigSkusGetRequest) Page(page int32) ApiApiAccountsMgmtV1ConfigSkusGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1ConfigSkusGetRequest) Size(size int32) ApiApiAccountsMgmtV1ConfigSkusGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1ConfigSkusGetRequest) Search(search string) ApiApiAccountsMgmtV1ConfigSkusGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1ConfigSkusGetRequest) Execute() (SkuList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ConfigSkusGetExecute(r)
}

/*
 * ApiAccountsMgmtV1ConfigSkusGet Returns a list of skus
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1ConfigSkusGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ConfigSkusGet(ctx _context.Context) ApiApiAccountsMgmtV1ConfigSkusGetRequest {
	return ApiApiAccountsMgmtV1ConfigSkusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return SkuList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ConfigSkusGetExecute(r ApiApiAccountsMgmtV1ConfigSkusGetRequest) (SkuList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SkuList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ConfigSkusGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/config/skus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ConfigSkusIdDeleteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
}


func (r ApiApiAccountsMgmtV1ConfigSkusIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ConfigSkusIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1ConfigSkusIdDelete Delete a sku
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1ConfigSkusIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ConfigSkusIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1ConfigSkusIdDeleteRequest {
	return ApiApiAccountsMgmtV1ConfigSkusIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ConfigSkusIdDeleteExecute(r ApiApiAccountsMgmtV1ConfigSkusIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ConfigSkusIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/config/skus/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ConfigSkusIdGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
}


func (r ApiApiAccountsMgmtV1ConfigSkusIdGetRequest) Execute() (SKU, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ConfigSkusIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1ConfigSkusIdGet Get a sku
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1ConfigSkusIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ConfigSkusIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1ConfigSkusIdGetRequest {
	return ApiApiAccountsMgmtV1ConfigSkusIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return SKU
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ConfigSkusIdGetExecute(r ApiApiAccountsMgmtV1ConfigSkusIdGetRequest) (SKU, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SKU
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ConfigSkusIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/config/skus/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ConfigSkusIdPatchRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	sKU *SKU
}

func (r ApiApiAccountsMgmtV1ConfigSkusIdPatchRequest) SKU(sKU SKU) ApiApiAccountsMgmtV1ConfigSkusIdPatchRequest {
	r.sKU = &sKU
	return r
}

func (r ApiApiAccountsMgmtV1ConfigSkusIdPatchRequest) Execute() (SKU, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ConfigSkusIdPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1ConfigSkusIdPatch Update a Sku
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1ConfigSkusIdPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ConfigSkusIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1ConfigSkusIdPatchRequest {
	return ApiApiAccountsMgmtV1ConfigSkusIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return SKU
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ConfigSkusIdPatchExecute(r ApiApiAccountsMgmtV1ConfigSkusIdPatchRequest) (SKU, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SKU
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ConfigSkusIdPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/config/skus/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.sKU == nil {
		return localVarReturnValue, nil, reportError("sKU is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sKU
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ConfigSkusPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	sKU *SKU
}

func (r ApiApiAccountsMgmtV1ConfigSkusPostRequest) SKU(sKU SKU) ApiApiAccountsMgmtV1ConfigSkusPostRequest {
	r.sKU = &sKU
	return r
}

func (r ApiApiAccountsMgmtV1ConfigSkusPostRequest) Execute() (SKU, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ConfigSkusPostExecute(r)
}

/*
 * ApiAccountsMgmtV1ConfigSkusPost Create a new sku
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1ConfigSkusPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ConfigSkusPost(ctx _context.Context) ApiApiAccountsMgmtV1ConfigSkusPostRequest {
	return ApiApiAccountsMgmtV1ConfigSkusPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return SKU
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ConfigSkusPostExecute(r ApiApiAccountsMgmtV1ConfigSkusPostRequest) (SKU, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SKU
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ConfigSkusPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/config/skus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.sKU == nil {
		return localVarReturnValue, nil, reportError("sKU is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sKU
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1DeletedSubscriptionsGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	page *int32
	size *int32
	search *string
	orderBy *string
}

func (r ApiApiAccountsMgmtV1DeletedSubscriptionsGetRequest) Page(page int32) ApiApiAccountsMgmtV1DeletedSubscriptionsGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1DeletedSubscriptionsGetRequest) Size(size int32) ApiApiAccountsMgmtV1DeletedSubscriptionsGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1DeletedSubscriptionsGetRequest) Search(search string) ApiApiAccountsMgmtV1DeletedSubscriptionsGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1DeletedSubscriptionsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1DeletedSubscriptionsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1DeletedSubscriptionsGetRequest) Execute() (DeletedSubscriptionList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1DeletedSubscriptionsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1DeletedSubscriptionsGet Returns a list of deleted subscriptions
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1DeletedSubscriptionsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1DeletedSubscriptionsGet(ctx _context.Context) ApiApiAccountsMgmtV1DeletedSubscriptionsGetRequest {
	return ApiApiAccountsMgmtV1DeletedSubscriptionsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DeletedSubscriptionList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1DeletedSubscriptionsGetExecute(r ApiApiAccountsMgmtV1DeletedSubscriptionsGetRequest) (DeletedSubscriptionList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DeletedSubscriptionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1DeletedSubscriptionsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/deleted_subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["AccessToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ErrorsGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	page *int32
	size *int32
	search *string
}

func (r ApiApiAccountsMgmtV1ErrorsGetRequest) Page(page int32) ApiApiAccountsMgmtV1ErrorsGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1ErrorsGetRequest) Size(size int32) ApiApiAccountsMgmtV1ErrorsGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1ErrorsGetRequest) Search(search string) ApiApiAccountsMgmtV1ErrorsGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1ErrorsGetRequest) Execute() (ErrorList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ErrorsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1ErrorsGet Returns a list of errors
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1ErrorsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ErrorsGet(ctx _context.Context) ApiApiAccountsMgmtV1ErrorsGetRequest {
	return ApiApiAccountsMgmtV1ErrorsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ErrorList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ErrorsGetExecute(r ApiApiAccountsMgmtV1ErrorsGetRequest) (ErrorList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ErrorList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ErrorsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/errors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ErrorsIdGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
}


func (r ApiApiAccountsMgmtV1ErrorsIdGetRequest) Execute() (Error, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ErrorsIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1ErrorsIdGet Get an error by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1ErrorsIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ErrorsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1ErrorsIdGetRequest {
	return ApiApiAccountsMgmtV1ErrorsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return Error
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ErrorsIdGetExecute(r ApiApiAccountsMgmtV1ErrorsIdGetRequest) (Error, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Error
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ErrorsIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/errors/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	featureToggleQueryRequest *FeatureToggleQueryRequest
}

func (r ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest) FeatureToggleQueryRequest(featureToggleQueryRequest FeatureToggleQueryRequest) ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest {
	r.featureToggleQueryRequest = &featureToggleQueryRequest
	return r
}

func (r ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest) Execute() (FeatureToggle, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1FeatureTogglesIdQueryPostExecute(r)
}

/*
 * ApiAccountsMgmtV1FeatureTogglesIdQueryPost Query a feature toggle by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1FeatureTogglesIdQueryPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest {
	return ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return FeatureToggle
 */
func (a *DefaultApiService) ApiAccountsMgmtV1FeatureTogglesIdQueryPostExecute(r ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest) (FeatureToggle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FeatureToggle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1FeatureTogglesIdQueryPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/feature_toggles/{id}/query"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.featureToggleQueryRequest == nil {
		return localVarReturnValue, nil, reportError("featureToggleQueryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.featureToggleQueryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1LabelsGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	page *int32
	size *int32
	search *string
	orderBy *string
}

func (r ApiApiAccountsMgmtV1LabelsGetRequest) Page(page int32) ApiApiAccountsMgmtV1LabelsGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1LabelsGetRequest) Size(size int32) ApiApiAccountsMgmtV1LabelsGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1LabelsGetRequest) Search(search string) ApiApiAccountsMgmtV1LabelsGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1LabelsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1LabelsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1LabelsGetRequest) Execute() (LabelList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1LabelsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1LabelsGet Returns a list of labels
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1LabelsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1LabelsGet(ctx _context.Context) ApiApiAccountsMgmtV1LabelsGetRequest {
	return ApiApiAccountsMgmtV1LabelsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return LabelList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1LabelsGetExecute(r ApiApiAccountsMgmtV1LabelsGetRequest) (LabelList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LabelList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1LabelsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/labels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1LandingPageSelfServiceGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiApiAccountsMgmtV1LandingPageSelfServiceGetRequest) Execute() (SelfServiceLandingPageSchema, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1LandingPageSelfServiceGetExecute(r)
}

/*
 * ApiAccountsMgmtV1LandingPageSelfServiceGet Get a console.redhat.com landing page content JSON schema
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1LandingPageSelfServiceGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1LandingPageSelfServiceGet(ctx _context.Context) ApiApiAccountsMgmtV1LandingPageSelfServiceGetRequest {
	return ApiApiAccountsMgmtV1LandingPageSelfServiceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return SelfServiceLandingPageSchema
 */
func (a *DefaultApiService) ApiAccountsMgmtV1LandingPageSelfServiceGetExecute(r ApiApiAccountsMgmtV1LandingPageSelfServiceGetRequest) (SelfServiceLandingPageSchema, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SelfServiceLandingPageSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1LandingPageSelfServiceGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/landing_page/self_service"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1MetricsGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	search *string
}

func (r ApiApiAccountsMgmtV1MetricsGetRequest) Search(search string) ApiApiAccountsMgmtV1MetricsGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1MetricsGetRequest) Execute() (MetricsList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1MetricsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1MetricsGet Returns a list of metrics
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1MetricsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1MetricsGet(ctx _context.Context) ApiApiAccountsMgmtV1MetricsGetRequest {
	return ApiApiAccountsMgmtV1MetricsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return MetricsList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1MetricsGetExecute(r ApiApiAccountsMgmtV1MetricsGetRequest) (MetricsList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MetricsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1MetricsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/metrics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1NotifyPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	notificationRequest *NotificationRequest
}

func (r ApiApiAccountsMgmtV1NotifyPostRequest) NotificationRequest(notificationRequest NotificationRequest) ApiApiAccountsMgmtV1NotifyPostRequest {
	r.notificationRequest = &notificationRequest
	return r
}

func (r ApiApiAccountsMgmtV1NotifyPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1NotifyPostExecute(r)
}

/*
 * ApiAccountsMgmtV1NotifyPost Notify the owner of cluster/subscription
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1NotifyPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1NotifyPost(ctx _context.Context) ApiApiAccountsMgmtV1NotifyPostRequest {
	return ApiApiAccountsMgmtV1NotifyPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1NotifyPostExecute(r ApiApiAccountsMgmtV1NotifyPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1NotifyPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/notify"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.notificationRequest == nil {
		return nil, reportError("notificationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	page *int32
	size *int32
	search *string
	orderBy *string
	fetchLabels *bool
	fetchCapabilities *bool
	fields *string
}

func (r ApiApiAccountsMgmtV1OrganizationsGetRequest) Page(page int32) ApiApiAccountsMgmtV1OrganizationsGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1OrganizationsGetRequest) Size(size int32) ApiApiAccountsMgmtV1OrganizationsGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1OrganizationsGetRequest) Search(search string) ApiApiAccountsMgmtV1OrganizationsGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1OrganizationsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1OrganizationsGetRequest {
	r.orderBy = &orderBy
	return r
}
func (r ApiApiAccountsMgmtV1OrganizationsGetRequest) FetchLabels(fetchLabels bool) ApiApiAccountsMgmtV1OrganizationsGetRequest {
	r.fetchLabels = &fetchLabels
	return r
}
func (r ApiApiAccountsMgmtV1OrganizationsGetRequest) FetchCapabilities(fetchCapabilities bool) ApiApiAccountsMgmtV1OrganizationsGetRequest {
	r.fetchCapabilities = &fetchCapabilities
	return r
}
func (r ApiApiAccountsMgmtV1OrganizationsGetRequest) Fields(fields string) ApiApiAccountsMgmtV1OrganizationsGetRequest {
	r.fields = &fields
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsGetRequest) Execute() (OrganizationList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsGet Returns a list of organizations
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1OrganizationsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsGet(ctx _context.Context) ApiApiAccountsMgmtV1OrganizationsGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return OrganizationList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsGetExecute(r ApiApiAccountsMgmtV1OrganizationsGetRequest) (OrganizationList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OrganizationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	if r.fetchLabels != nil {
		localVarQueryParams.Add("fetchLabels", parameterToString(*r.fetchLabels, ""))
	}
	if r.fetchCapabilities != nil {
		localVarQueryParams.Add("fetchCapabilities", parameterToString(*r.fetchCapabilities, ""))
	}
	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsIdGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	fetchLabels *bool
	fetchCapabilities *bool
}

func (r ApiApiAccountsMgmtV1OrganizationsIdGetRequest) FetchLabels(fetchLabels bool) ApiApiAccountsMgmtV1OrganizationsIdGetRequest {
	r.fetchLabels = &fetchLabels
	return r
}
func (r ApiApiAccountsMgmtV1OrganizationsIdGetRequest) FetchCapabilities(fetchCapabilities bool) ApiApiAccountsMgmtV1OrganizationsIdGetRequest {
	r.fetchCapabilities = &fetchCapabilities
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsIdGetRequest) Execute() (Organization, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsIdGet Get an organization by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1OrganizationsIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return Organization
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdGetExecute(r ApiApiAccountsMgmtV1OrganizationsIdGetRequest) (Organization, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fetchLabels != nil {
		localVarQueryParams.Add("fetchLabels", parameterToString(*r.fetchLabels, ""))
	}
	if r.fetchCapabilities != nil {
		localVarQueryParams.Add("fetchCapabilities", parameterToString(*r.fetchCapabilities, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	page *int32
	size *int32
	search *string
	orderBy *string
}

func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest) Page(page int32) ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest) Size(size int32) ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest) Search(search string) ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest) Execute() (LabelList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsIdLabelsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsIdLabelsGet Returns a list of labels
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return LabelList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsGetExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest) (LabelList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LabelList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsIdLabelsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	key string
}


func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsIdLabelsKeyDelete Delete a label
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param key The key of the label
 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsKeyDelete(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteRequest {
	return ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		key: key,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsIdLabelsKeyDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{id}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	key string
}


func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyGetRequest) Execute() (Label, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsIdLabelsKeyGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsIdLabelsKeyGet Get subscription labels by label key
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param key The key of the label
 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsKeyGet(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		key: key,
	}
}

/*
 * Execute executes the request
 * @return Label
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsKeyGetExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyGetRequest) (Label, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Label
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsIdLabelsKeyGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{id}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	key string
	label *Label
}

func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest) Label(label Label) ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest {
	r.label = &label
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest) Execute() (Label, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsIdLabelsKeyPatch Create a new label or update an existing label
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param key The key of the label
 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsKeyPatch(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest {
	return ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		key: key,
	}
}

/*
 * Execute executes the request
 * @return Label
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest) (Label, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Label
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsIdLabelsKeyPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{id}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.label == nil {
		return localVarReturnValue, nil, reportError("label is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.label
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	label *Label
}

func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest) Label(label Label) ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest {
	r.label = &label
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest) Execute() (Label, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsIdLabelsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsIdLabelsPost Create a new label or update an existing label
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest {
	return ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return Label
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsPostExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest) (Label, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Label
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsIdLabelsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.label == nil {
		return localVarReturnValue, nil, reportError("label is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.label
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsIdPatchRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	organizationPatchRequest *OrganizationPatchRequest
}

func (r ApiApiAccountsMgmtV1OrganizationsIdPatchRequest) OrganizationPatchRequest(organizationPatchRequest OrganizationPatchRequest) ApiApiAccountsMgmtV1OrganizationsIdPatchRequest {
	r.organizationPatchRequest = &organizationPatchRequest
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsIdPatchRequest) Execute() (Organization, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsIdPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsIdPatch Update an organization
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1OrganizationsIdPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdPatchRequest {
	return ApiApiAccountsMgmtV1OrganizationsIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return Organization
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdPatchExecute(r ApiApiAccountsMgmtV1OrganizationsIdPatchRequest) (Organization, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsIdPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.organizationPatchRequest == nil {
		return localVarReturnValue, nil, reportError("organizationPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.organizationPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
}


func (r ApiApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetRequest) Execute() (Summary, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsIdSummaryDashboardGet Returns a summary of organizations clusters based on metrics
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdSummaryDashboardGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return Summary
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetExecute(r ApiApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetRequest) (Summary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Summary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsIdSummaryDashboardGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{id}/summary_dashboard"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdDeleteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	orgId string
	acctGrpAsgnId string
}


func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdDelete Delete an account group assignment
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @param acctGrpAsgnId The id of account group assignment
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdDelete(ctx _context.Context, orgId string, acctGrpAsgnId string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdDeleteRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		acctGrpAsgnId: acctGrpAsgnId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdDeleteExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/account_group_assignments/{acctGrpAsgnId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"acctGrpAsgnId"+"}", _neturl.PathEscape(parameterToString(r.acctGrpAsgnId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	orgId string
	acctGrpAsgnId string
}


func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdGetRequest) Execute() (AccountGroupAssignment, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdGet Get account group assignment by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @param acctGrpAsgnId The id of account group assignment
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdGet(ctx _context.Context, orgId string, acctGrpAsgnId string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdGetRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		acctGrpAsgnId: acctGrpAsgnId,
	}
}

/*
 * Execute executes the request
 * @return AccountGroupAssignment
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdGetRequest) (AccountGroupAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccountGroupAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsAcctGrpAsgnIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/account_group_assignments/{acctGrpAsgnId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"acctGrpAsgnId"+"}", _neturl.PathEscape(parameterToString(r.acctGrpAsgnId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	orgId string
	page *int32
	size *int32
	search *string
	orderBy *string
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetRequest) Page(page int32) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetRequest) Size(size int32) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetRequest) Search(search string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetRequest) Execute() (AccountGroupAssignmentList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGet Returns a list of account group assignments for the given org
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGet(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

/*
 * Execute executes the request
 * @return AccountGroupAssignmentList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGetRequest) (AccountGroupAssignmentList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccountGroupAssignmentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/account_group_assignments"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	orgId string
	accountGroupAssignment *AccountGroupAssignment
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPostRequest) AccountGroupAssignment(accountGroupAssignment AccountGroupAssignment) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPostRequest {
	r.accountGroupAssignment = &accountGroupAssignment
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPostRequest) Execute() (AccountGroupAssignment, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPost Create a new AccountGroupAssignment
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPost(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPostRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPostRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

/*
 * Execute executes the request
 * @return AccountGroupAssignment
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPostExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPostRequest) (AccountGroupAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccountGroupAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupAssignmentsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/account_group_assignments"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.accountGroupAssignment == nil {
		return localVarReturnValue, nil, reportError("accountGroupAssignment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountGroupAssignment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdDeleteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	orgId string
	acctGrpId string
}


func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdDelete Delete an account group
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @param acctGrpId The id of account group
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdDelete(ctx _context.Context, orgId string, acctGrpId string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdDeleteRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		acctGrpId: acctGrpId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdDeleteExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/account_groups/{acctGrpId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"acctGrpId"+"}", _neturl.PathEscape(parameterToString(r.acctGrpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	orgId string
	acctGrpId string
}


func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdGetRequest) Execute() (AccountGroup, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdGet Get account group by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @param acctGrpId The id of account group
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdGet(ctx _context.Context, orgId string, acctGrpId string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdGetRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		acctGrpId: acctGrpId,
	}
}

/*
 * Execute executes the request
 * @return AccountGroup
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdGetRequest) (AccountGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccountGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/account_groups/{acctGrpId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"acctGrpId"+"}", _neturl.PathEscape(parameterToString(r.acctGrpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatchRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	orgId string
	acctGrpId string
	accountGroupRequest *AccountGroupRequest
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatchRequest) AccountGroupRequest(accountGroupRequest AccountGroupRequest) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatchRequest {
	r.accountGroupRequest = &accountGroupRequest
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatchRequest) Execute() (AccountGroup, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatch Update an account group
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @param acctGrpId The id of account group
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatch(ctx _context.Context, orgId string, acctGrpId string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatchRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		acctGrpId: acctGrpId,
	}
}

/*
 * Execute executes the request
 * @return AccountGroup
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatchExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatchRequest) (AccountGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccountGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsAcctGrpIdPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/account_groups/{acctGrpId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"acctGrpId"+"}", _neturl.PathEscape(parameterToString(r.acctGrpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.accountGroupRequest == nil {
		return localVarReturnValue, nil, reportError("accountGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountGroupRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	orgId string
	page *int32
	size *int32
	search *string
	orderBy *string
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetRequest) Page(page int32) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetRequest) Size(size int32) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetRequest) Search(search string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetRequest) Execute() (AccountGroupList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGet Returns a list of account groups for the given org
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGet(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

/*
 * Execute executes the request
 * @return AccountGroupList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGetRequest) (AccountGroupList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccountGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/account_groups"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	orgId string
	accountGroupRequest *AccountGroupRequest
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPostRequest) AccountGroupRequest(accountGroupRequest AccountGroupRequest) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPostRequest {
	r.accountGroupRequest = &accountGroupRequest
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPostRequest) Execute() (AccountGroup, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPost Create a new AccountGroup
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPost(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPostRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPostRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

/*
 * Execute executes the request
 * @return AccountGroup
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPostExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPostRequest) (AccountGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccountGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdAccountGroupsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/account_groups"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.accountGroupRequest == nil {
		return localVarReturnValue, nil, reportError("accountGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountGroupRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	orgId string
	forceRecalc *bool
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGetRequest) ForceRecalc(forceRecalc bool) ApiApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGetRequest {
	r.forceRecalc = &forceRecalc
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGetRequest) Execute() (ConsumedQuotaList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGet Returns a list of consumed quota for an organization
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGet(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGetRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

/*
 * Execute executes the request
 * @return ConsumedQuotaList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGetRequest) (ConsumedQuotaList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ConsumedQuotaList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdConsumedQuotaGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/consumed_quota"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.forceRecalc != nil {
		localVarQueryParams.Add("forceRecalc", parameterToString(*r.forceRecalc, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	orgId string
	page *int32
	size *int32
	search *string
	orderBy *string
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest) Page(page int32) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest) Size(size int32) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest) Search(search string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest) Execute() (ResourceQuotaList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGet Returns a list of resource quota objects
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGet(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

/*
 * Execute executes the request
 * @return ResourceQuotaList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest) (ResourceQuotaList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceQuotaList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/resource_quota"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	orgId string
	resourceQuotaRequest *ResourceQuotaRequest
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest) ResourceQuotaRequest(resourceQuotaRequest ResourceQuotaRequest) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest {
	r.resourceQuotaRequest = &resourceQuotaRequest
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest) Execute() (ResourceQuota, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPost Create a new resource quota
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPost(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

/*
 * Execute executes the request
 * @return ResourceQuota
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest) (ResourceQuota, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceQuota
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/resource_quota"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.resourceQuotaRequest == nil {
		return localVarReturnValue, nil, reportError("resourceQuotaRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resourceQuotaRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	orgId string
	quotaId string
}


func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDelete Delete a resource quota
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @param quotaId The id of quota
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDelete(ctx _context.Context, orgId string, quotaId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		quotaId: quotaId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/resource_quota/{quotaId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"quotaId"+"}", _neturl.PathEscape(parameterToString(r.quotaId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	orgId string
	quotaId string
}


func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetRequest) Execute() (ResourceQuota, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGet Get a resource quota by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @param quotaId The id of quota
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGet(ctx _context.Context, orgId string, quotaId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		quotaId: quotaId,
	}
}

/*
 * Execute executes the request
 * @return ResourceQuota
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetRequest) (ResourceQuota, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceQuota
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/resource_quota/{quotaId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"quotaId"+"}", _neturl.PathEscape(parameterToString(r.quotaId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	orgId string
	quotaId string
	resourceQuotaRequest *ResourceQuotaRequest
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest) ResourceQuotaRequest(resourceQuotaRequest ResourceQuotaRequest) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest {
	r.resourceQuotaRequest = &resourceQuotaRequest
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest) Execute() (ResourceQuota, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatch Update a resource quota
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @param quotaId The id of quota
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatch(ctx _context.Context, orgId string, quotaId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		quotaId: quotaId,
	}
}

/*
 * Execute executes the request
 * @return ResourceQuota
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest) (ResourceQuota, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceQuota
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/resource_quota/{quotaId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"quotaId"+"}", _neturl.PathEscape(parameterToString(r.quotaId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.resourceQuotaRequest == nil {
		return localVarReturnValue, nil, reportError("resourceQuotaRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resourceQuotaRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	organization *Organization
}

func (r ApiApiAccountsMgmtV1OrganizationsPostRequest) Organization(organization Organization) ApiApiAccountsMgmtV1OrganizationsPostRequest {
	r.organization = &organization
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsPostRequest) Execute() (Organization, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsPost Create a new organization
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1OrganizationsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsPost(ctx _context.Context) ApiApiAccountsMgmtV1OrganizationsPostRequest {
	return ApiApiAccountsMgmtV1OrganizationsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return Organization
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsPostExecute(r ApiApiAccountsMgmtV1OrganizationsPostRequest) (Organization, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.organization == nil {
		return localVarReturnValue, nil, reportError("organization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.organization
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1PlansGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	page *int32
	size *int32
	search *string
}

func (r ApiApiAccountsMgmtV1PlansGetRequest) Page(page int32) ApiApiAccountsMgmtV1PlansGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1PlansGetRequest) Size(size int32) ApiApiAccountsMgmtV1PlansGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1PlansGetRequest) Search(search string) ApiApiAccountsMgmtV1PlansGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1PlansGetRequest) Execute() (PlanList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1PlansGetExecute(r)
}

/*
 * ApiAccountsMgmtV1PlansGet Get all plans
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1PlansGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1PlansGet(ctx _context.Context) ApiApiAccountsMgmtV1PlansGetRequest {
	return ApiApiAccountsMgmtV1PlansGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return PlanList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1PlansGetExecute(r ApiApiAccountsMgmtV1PlansGetRequest) (PlanList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PlanList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1PlansGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/plans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1PlansIdGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
}


func (r ApiApiAccountsMgmtV1PlansIdGetRequest) Execute() (Plan, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1PlansIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1PlansIdGet Get a plan by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1PlansIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1PlansIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1PlansIdGetRequest {
	return ApiApiAccountsMgmtV1PlansIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return Plan
 */
func (a *DefaultApiService) ApiAccountsMgmtV1PlansIdGetExecute(r ApiApiAccountsMgmtV1PlansIdGetRequest) (Plan, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Plan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1PlansIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/plans/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	externalResourceId string
}


func (r ApiApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1PullSecretsExternalResourceIdDelete Delete a pull secret
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param externalResourceId The external resource id of record
 * @return ApiApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1PullSecretsExternalResourceIdDelete(ctx _context.Context, externalResourceId string) ApiApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteRequest {
	return ApiApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		externalResourceId: externalResourceId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteExecute(r ApiApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1PullSecretsExternalResourceIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/pull_secrets/{externalResourceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"externalResourceId"+"}", _neturl.PathEscape(parameterToString(r.externalResourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1PullSecretsPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	pullSecretRequest *PullSecretRequest
}

func (r ApiApiAccountsMgmtV1PullSecretsPostRequest) PullSecretRequest(pullSecretRequest PullSecretRequest) ApiApiAccountsMgmtV1PullSecretsPostRequest {
	r.pullSecretRequest = &pullSecretRequest
	return r
}

func (r ApiApiAccountsMgmtV1PullSecretsPostRequest) Execute() (AccessTokenCfg, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1PullSecretsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1PullSecretsPost Return access token generated from registries in docker format
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1PullSecretsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1PullSecretsPost(ctx _context.Context) ApiApiAccountsMgmtV1PullSecretsPostRequest {
	return ApiApiAccountsMgmtV1PullSecretsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return AccessTokenCfg
 */
func (a *DefaultApiService) ApiAccountsMgmtV1PullSecretsPostExecute(r ApiApiAccountsMgmtV1PullSecretsPostRequest) (AccessTokenCfg, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccessTokenCfg
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1PullSecretsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/pull_secrets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.pullSecretRequest == nil {
		return localVarReturnValue, nil, reportError("pullSecretRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pullSecretRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1QuotaCostGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	search *string
	fetchRelatedResources *bool
	fetchCloudAccounts *bool
}

func (r ApiApiAccountsMgmtV1QuotaCostGetRequest) Search(search string) ApiApiAccountsMgmtV1QuotaCostGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1QuotaCostGetRequest) FetchRelatedResources(fetchRelatedResources bool) ApiApiAccountsMgmtV1QuotaCostGetRequest {
	r.fetchRelatedResources = &fetchRelatedResources
	return r
}
func (r ApiApiAccountsMgmtV1QuotaCostGetRequest) FetchCloudAccounts(fetchCloudAccounts bool) ApiApiAccountsMgmtV1QuotaCostGetRequest {
	r.fetchCloudAccounts = &fetchCloudAccounts
	return r
}

func (r ApiApiAccountsMgmtV1QuotaCostGetRequest) Execute() (QuotaCostList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1QuotaCostGetExecute(r)
}

/*
 * ApiAccountsMgmtV1QuotaCostGet Returns a summary of quota cost for the authenticated user
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1QuotaCostGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1QuotaCostGet(ctx _context.Context) ApiApiAccountsMgmtV1QuotaCostGetRequest {
	return ApiApiAccountsMgmtV1QuotaCostGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return QuotaCostList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1QuotaCostGetExecute(r ApiApiAccountsMgmtV1QuotaCostGetRequest) (QuotaCostList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  QuotaCostList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1QuotaCostGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/quota_cost"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.fetchRelatedResources != nil {
		localVarQueryParams.Add("fetchRelatedResources", parameterToString(*r.fetchRelatedResources, ""))
	}
	if r.fetchCloudAccounts != nil {
		localVarQueryParams.Add("fetchCloudAccounts", parameterToString(*r.fetchCloudAccounts, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1QuotaRulesGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	page *int32
	size *int32
	search *string
}

func (r ApiApiAccountsMgmtV1QuotaRulesGetRequest) Page(page int32) ApiApiAccountsMgmtV1QuotaRulesGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1QuotaRulesGetRequest) Size(size int32) ApiApiAccountsMgmtV1QuotaRulesGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1QuotaRulesGetRequest) Search(search string) ApiApiAccountsMgmtV1QuotaRulesGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1QuotaRulesGetRequest) Execute() (QuotaRulesList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1QuotaRulesGetExecute(r)
}

/*
 * ApiAccountsMgmtV1QuotaRulesGet Returns a list of UHC product Quota Rules
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1QuotaRulesGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1QuotaRulesGet(ctx _context.Context) ApiApiAccountsMgmtV1QuotaRulesGetRequest {
	return ApiApiAccountsMgmtV1QuotaRulesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return QuotaRulesList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1QuotaRulesGetExecute(r ApiApiAccountsMgmtV1QuotaRulesGetRequest) (QuotaRulesList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  QuotaRulesList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1QuotaRulesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/quota_rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1QuotasGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	page *int32
	size *int32
	search *string
}

func (r ApiApiAccountsMgmtV1QuotasGetRequest) Page(page int32) ApiApiAccountsMgmtV1QuotasGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1QuotasGetRequest) Size(size int32) ApiApiAccountsMgmtV1QuotasGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1QuotasGetRequest) Search(search string) ApiApiAccountsMgmtV1QuotasGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1QuotasGetRequest) Execute() (QuotaList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1QuotasGetExecute(r)
}

/*
 * ApiAccountsMgmtV1QuotasGet Returns a list of quotas
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1QuotasGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1QuotasGet(ctx _context.Context) ApiApiAccountsMgmtV1QuotasGetRequest {
	return ApiApiAccountsMgmtV1QuotasGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return QuotaList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1QuotasGetExecute(r ApiApiAccountsMgmtV1QuotasGetRequest) (QuotaList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  QuotaList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1QuotasGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/quotas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1QuotasIdDeleteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
}


func (r ApiApiAccountsMgmtV1QuotasIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1QuotasIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1QuotasIdDelete Delete a quota
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1QuotasIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1QuotasIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1QuotasIdDeleteRequest {
	return ApiApiAccountsMgmtV1QuotasIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1QuotasIdDeleteExecute(r ApiApiAccountsMgmtV1QuotasIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1QuotasIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/quotas/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1QuotasIdGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
}


func (r ApiApiAccountsMgmtV1QuotasIdGetRequest) Execute() (Quota, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1QuotasIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1QuotasIdGet Get a quota
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1QuotasIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1QuotasIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1QuotasIdGetRequest {
	return ApiApiAccountsMgmtV1QuotasIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return Quota
 */
func (a *DefaultApiService) ApiAccountsMgmtV1QuotasIdGetExecute(r ApiApiAccountsMgmtV1QuotasIdGetRequest) (Quota, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Quota
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1QuotasIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/quotas/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1QuotasIdPatchRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	quota *Quota
}

func (r ApiApiAccountsMgmtV1QuotasIdPatchRequest) Quota(quota Quota) ApiApiAccountsMgmtV1QuotasIdPatchRequest {
	r.quota = &quota
	return r
}

func (r ApiApiAccountsMgmtV1QuotasIdPatchRequest) Execute() (Quota, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1QuotasIdPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1QuotasIdPatch Update a quota
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1QuotasIdPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1QuotasIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1QuotasIdPatchRequest {
	return ApiApiAccountsMgmtV1QuotasIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return Quota
 */
func (a *DefaultApiService) ApiAccountsMgmtV1QuotasIdPatchExecute(r ApiApiAccountsMgmtV1QuotasIdPatchRequest) (Quota, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Quota
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1QuotasIdPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/quotas/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.quota == nil {
		return localVarReturnValue, nil, reportError("quota is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.quota
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1QuotasPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	quota *Quota
}

func (r ApiApiAccountsMgmtV1QuotasPostRequest) Quota(quota Quota) ApiApiAccountsMgmtV1QuotasPostRequest {
	r.quota = &quota
	return r
}

func (r ApiApiAccountsMgmtV1QuotasPostRequest) Execute() (Quota, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1QuotasPostExecute(r)
}

/*
 * ApiAccountsMgmtV1QuotasPost Create a new quota
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1QuotasPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1QuotasPost(ctx _context.Context) ApiApiAccountsMgmtV1QuotasPostRequest {
	return ApiApiAccountsMgmtV1QuotasPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return Quota
 */
func (a *DefaultApiService) ApiAccountsMgmtV1QuotasPostExecute(r ApiApiAccountsMgmtV1QuotasPostRequest) (Quota, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Quota
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1QuotasPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/quotas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.quota == nil {
		return localVarReturnValue, nil, reportError("quota is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.quota
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RegistriesGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	page *int32
	size *int32
	search *string
	orderBy *string
}

func (r ApiApiAccountsMgmtV1RegistriesGetRequest) Page(page int32) ApiApiAccountsMgmtV1RegistriesGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1RegistriesGetRequest) Size(size int32) ApiApiAccountsMgmtV1RegistriesGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1RegistriesGetRequest) Search(search string) ApiApiAccountsMgmtV1RegistriesGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1RegistriesGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1RegistriesGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1RegistriesGetRequest) Execute() (RegistryList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RegistriesGetExecute(r)
}

/*
 * ApiAccountsMgmtV1RegistriesGet Returns a list of registries
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1RegistriesGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistriesGet(ctx _context.Context) ApiApiAccountsMgmtV1RegistriesGetRequest {
	return ApiApiAccountsMgmtV1RegistriesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return RegistryList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistriesGetExecute(r ApiApiAccountsMgmtV1RegistriesGetRequest) (RegistryList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RegistryList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RegistriesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/registries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RegistriesIdGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
}


func (r ApiApiAccountsMgmtV1RegistriesIdGetRequest) Execute() (Registry, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RegistriesIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1RegistriesIdGet Get an registry by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1RegistriesIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistriesIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1RegistriesIdGetRequest {
	return ApiApiAccountsMgmtV1RegistriesIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return Registry
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistriesIdGetExecute(r ApiApiAccountsMgmtV1RegistriesIdGetRequest) (Registry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Registry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RegistriesIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/registries/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RegistryCredentialsGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	page *int32
	size *int32
	search *string
	orderBy *string
}

func (r ApiApiAccountsMgmtV1RegistryCredentialsGetRequest) Page(page int32) ApiApiAccountsMgmtV1RegistryCredentialsGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1RegistryCredentialsGetRequest) Size(size int32) ApiApiAccountsMgmtV1RegistryCredentialsGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1RegistryCredentialsGetRequest) Search(search string) ApiApiAccountsMgmtV1RegistryCredentialsGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1RegistryCredentialsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1RegistryCredentialsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1RegistryCredentialsGetRequest) Execute() (RegistryCredentialList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RegistryCredentialsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1RegistryCredentialsGet Method for ApiAccountsMgmtV1RegistryCredentialsGet
 * List Registry Credentials
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1RegistryCredentialsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsGet(ctx _context.Context) ApiApiAccountsMgmtV1RegistryCredentialsGetRequest {
	return ApiApiAccountsMgmtV1RegistryCredentialsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return RegistryCredentialList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsGetExecute(r ApiApiAccountsMgmtV1RegistryCredentialsGetRequest) (RegistryCredentialList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RegistryCredentialList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RegistryCredentialsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/registry_credentials"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RegistryCredentialsIdDeleteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
}


func (r ApiApiAccountsMgmtV1RegistryCredentialsIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RegistryCredentialsIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1RegistryCredentialsIdDelete Delete a registry credential by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1RegistryCredentialsIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1RegistryCredentialsIdDeleteRequest {
	return ApiApiAccountsMgmtV1RegistryCredentialsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsIdDeleteExecute(r ApiApiAccountsMgmtV1RegistryCredentialsIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RegistryCredentialsIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/registry_credentials/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RegistryCredentialsIdGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
}


func (r ApiApiAccountsMgmtV1RegistryCredentialsIdGetRequest) Execute() (RegistryCredential, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RegistryCredentialsIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1RegistryCredentialsIdGet Get a registry credentials by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1RegistryCredentialsIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1RegistryCredentialsIdGetRequest {
	return ApiApiAccountsMgmtV1RegistryCredentialsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return RegistryCredential
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsIdGetExecute(r ApiApiAccountsMgmtV1RegistryCredentialsIdGetRequest) (RegistryCredential, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RegistryCredential
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RegistryCredentialsIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/registry_credentials/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	registryCredentialPatchRequest *RegistryCredentialPatchRequest
}

func (r ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest) RegistryCredentialPatchRequest(registryCredentialPatchRequest RegistryCredentialPatchRequest) ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest {
	r.registryCredentialPatchRequest = &registryCredentialPatchRequest
	return r
}

func (r ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest) Execute() (RegistryCredential, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RegistryCredentialsIdPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1RegistryCredentialsIdPatch Update a registry credential
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest {
	return ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return RegistryCredential
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsIdPatchExecute(r ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest) (RegistryCredential, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RegistryCredential
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RegistryCredentialsIdPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/registry_credentials/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.registryCredentialPatchRequest == nil {
		return localVarReturnValue, nil, reportError("registryCredentialPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.registryCredentialPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RegistryCredentialsPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	registryCredential *RegistryCredential
}

func (r ApiApiAccountsMgmtV1RegistryCredentialsPostRequest) RegistryCredential(registryCredential RegistryCredential) ApiApiAccountsMgmtV1RegistryCredentialsPostRequest {
	r.registryCredential = &registryCredential
	return r
}

func (r ApiApiAccountsMgmtV1RegistryCredentialsPostRequest) Execute() (RegistryCredential, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RegistryCredentialsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1RegistryCredentialsPost Request the creation of a registry credential
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1RegistryCredentialsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsPost(ctx _context.Context) ApiApiAccountsMgmtV1RegistryCredentialsPostRequest {
	return ApiApiAccountsMgmtV1RegistryCredentialsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return RegistryCredential
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsPostExecute(r ApiApiAccountsMgmtV1RegistryCredentialsPostRequest) (RegistryCredential, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RegistryCredential
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RegistryCredentialsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/registry_credentials"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.registryCredential == nil {
		return localVarReturnValue, nil, reportError("registryCredential is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.registryCredential
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ReservedResourcesGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	page *int32
	size *int32
	search *string
	orderBy *string
}

func (r ApiApiAccountsMgmtV1ReservedResourcesGetRequest) Page(page int32) ApiApiAccountsMgmtV1ReservedResourcesGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1ReservedResourcesGetRequest) Size(size int32) ApiApiAccountsMgmtV1ReservedResourcesGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1ReservedResourcesGetRequest) Search(search string) ApiApiAccountsMgmtV1ReservedResourcesGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1ReservedResourcesGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1ReservedResourcesGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1ReservedResourcesGetRequest) Execute() (ReservedResourceList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ReservedResourcesGetExecute(r)
}

/*
 * ApiAccountsMgmtV1ReservedResourcesGet Returns a list of reserved resources
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1ReservedResourcesGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ReservedResourcesGet(ctx _context.Context) ApiApiAccountsMgmtV1ReservedResourcesGetRequest {
	return ApiApiAccountsMgmtV1ReservedResourcesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ReservedResourceList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ReservedResourcesGetExecute(r ApiApiAccountsMgmtV1ReservedResourcesGetRequest) (ReservedResourceList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReservedResourceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ReservedResourcesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/reserved_resources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ResourceQuotaGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	page *int32
	size *int32
	search *string
	orderBy *string
}

func (r ApiApiAccountsMgmtV1ResourceQuotaGetRequest) Page(page int32) ApiApiAccountsMgmtV1ResourceQuotaGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1ResourceQuotaGetRequest) Size(size int32) ApiApiAccountsMgmtV1ResourceQuotaGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1ResourceQuotaGetRequest) Search(search string) ApiApiAccountsMgmtV1ResourceQuotaGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1ResourceQuotaGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1ResourceQuotaGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1ResourceQuotaGetRequest) Execute() (ResourceQuotaList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ResourceQuotaGetExecute(r)
}

/*
 * ApiAccountsMgmtV1ResourceQuotaGet Returns a list of resource quota objects
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1ResourceQuotaGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ResourceQuotaGet(ctx _context.Context) ApiApiAccountsMgmtV1ResourceQuotaGetRequest {
	return ApiApiAccountsMgmtV1ResourceQuotaGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ResourceQuotaList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ResourceQuotaGetExecute(r ApiApiAccountsMgmtV1ResourceQuotaGetRequest) (ResourceQuotaList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceQuotaList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ResourceQuotaGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/resource_quota"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RoleBindingsGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	page *int32
	size *int32
	search *string
	orderBy *string
}

func (r ApiApiAccountsMgmtV1RoleBindingsGetRequest) Page(page int32) ApiApiAccountsMgmtV1RoleBindingsGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1RoleBindingsGetRequest) Size(size int32) ApiApiAccountsMgmtV1RoleBindingsGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1RoleBindingsGetRequest) Search(search string) ApiApiAccountsMgmtV1RoleBindingsGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1RoleBindingsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1RoleBindingsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1RoleBindingsGetRequest) Execute() (RoleBindingList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RoleBindingsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1RoleBindingsGet Returns a list of role bindings
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1RoleBindingsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsGet(ctx _context.Context) ApiApiAccountsMgmtV1RoleBindingsGetRequest {
	return ApiApiAccountsMgmtV1RoleBindingsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return RoleBindingList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsGetExecute(r ApiApiAccountsMgmtV1RoleBindingsGetRequest) (RoleBindingList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RoleBindingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RoleBindingsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/role_bindings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RoleBindingsIdDeleteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
}


func (r ApiApiAccountsMgmtV1RoleBindingsIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RoleBindingsIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1RoleBindingsIdDelete Delete a role binding
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1RoleBindingsIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1RoleBindingsIdDeleteRequest {
	return ApiApiAccountsMgmtV1RoleBindingsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsIdDeleteExecute(r ApiApiAccountsMgmtV1RoleBindingsIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RoleBindingsIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/role_bindings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RoleBindingsIdGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
}


func (r ApiApiAccountsMgmtV1RoleBindingsIdGetRequest) Execute() (RoleBinding, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RoleBindingsIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1RoleBindingsIdGet Get a role binding
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1RoleBindingsIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1RoleBindingsIdGetRequest {
	return ApiApiAccountsMgmtV1RoleBindingsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return RoleBinding
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsIdGetExecute(r ApiApiAccountsMgmtV1RoleBindingsIdGetRequest) (RoleBinding, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RoleBindingsIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/role_bindings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	roleBindingRequest *RoleBindingRequest
}

func (r ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest) RoleBindingRequest(roleBindingRequest RoleBindingRequest) ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest {
	r.roleBindingRequest = &roleBindingRequest
	return r
}

func (r ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest) Execute() (RoleBinding, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RoleBindingsIdPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1RoleBindingsIdPatch Update a role binding
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest {
	return ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return RoleBinding
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsIdPatchExecute(r ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest) (RoleBinding, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RoleBindingsIdPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/role_bindings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.roleBindingRequest == nil {
		return localVarReturnValue, nil, reportError("roleBindingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleBindingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RoleBindingsPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	roleBindingCreateRequest *RoleBindingCreateRequest
}

func (r ApiApiAccountsMgmtV1RoleBindingsPostRequest) RoleBindingCreateRequest(roleBindingCreateRequest RoleBindingCreateRequest) ApiApiAccountsMgmtV1RoleBindingsPostRequest {
	r.roleBindingCreateRequest = &roleBindingCreateRequest
	return r
}

func (r ApiApiAccountsMgmtV1RoleBindingsPostRequest) Execute() (RoleBinding, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RoleBindingsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1RoleBindingsPost Create a new role binding
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1RoleBindingsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsPost(ctx _context.Context) ApiApiAccountsMgmtV1RoleBindingsPostRequest {
	return ApiApiAccountsMgmtV1RoleBindingsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return RoleBinding
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsPostExecute(r ApiApiAccountsMgmtV1RoleBindingsPostRequest) (RoleBinding, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RoleBindingsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/role_bindings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.roleBindingCreateRequest == nil {
		return localVarReturnValue, nil, reportError("roleBindingCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleBindingCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RolesGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	page *int32
	size *int32
	search *string
}

func (r ApiApiAccountsMgmtV1RolesGetRequest) Page(page int32) ApiApiAccountsMgmtV1RolesGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1RolesGetRequest) Size(size int32) ApiApiAccountsMgmtV1RolesGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1RolesGetRequest) Search(search string) ApiApiAccountsMgmtV1RolesGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1RolesGetRequest) Execute() (RoleList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RolesGetExecute(r)
}

/*
 * ApiAccountsMgmtV1RolesGet Returns a list of roles
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1RolesGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RolesGet(ctx _context.Context) ApiApiAccountsMgmtV1RolesGetRequest {
	return ApiApiAccountsMgmtV1RolesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return RoleList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RolesGetExecute(r ApiApiAccountsMgmtV1RolesGetRequest) (RoleList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RoleList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RolesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RolesIdGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
}


func (r ApiApiAccountsMgmtV1RolesIdGetRequest) Execute() (Role, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RolesIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1RolesIdGet Get a role by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1RolesIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RolesIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1RolesIdGetRequest {
	return ApiApiAccountsMgmtV1RolesIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return Role
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RolesIdGetExecute(r ApiApiAccountsMgmtV1RolesIdGetRequest) (Role, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RolesIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/roles/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SelfEntitlementProductPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	product string
}


func (r ApiApiAccountsMgmtV1SelfEntitlementProductPostRequest) Execute() (SelfEntitlementStatus, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SelfEntitlementProductPostExecute(r)
}

/*
 * ApiAccountsMgmtV1SelfEntitlementProductPost Create or renew the entitlement to support a product for the user's organization.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param product The product for self_entitlement. The supported products are [rosa].
 * @return ApiApiAccountsMgmtV1SelfEntitlementProductPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SelfEntitlementProductPost(ctx _context.Context, product string) ApiApiAccountsMgmtV1SelfEntitlementProductPostRequest {
	return ApiApiAccountsMgmtV1SelfEntitlementProductPostRequest{
		ApiService: a,
		ctx: ctx,
		product: product,
	}
}

/*
 * Execute executes the request
 * @return SelfEntitlementStatus
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SelfEntitlementProductPostExecute(r ApiApiAccountsMgmtV1SelfEntitlementProductPostRequest) (SelfEntitlementStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SelfEntitlementStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SelfEntitlementProductPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/self_entitlement/{product}"
	localVarPath = strings.Replace(localVarPath, "{"+"product"+"}", _neturl.PathEscape(parameterToString(r.product, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SkuRulesGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	search *string
}

func (r ApiApiAccountsMgmtV1SkuRulesGetRequest) Search(search string) ApiApiAccountsMgmtV1SkuRulesGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1SkuRulesGetRequest) Execute() (SkuRulesList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SkuRulesGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SkuRulesGet Returns a list of UHC product SKU Rules
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1SkuRulesGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkuRulesGet(ctx _context.Context) ApiApiAccountsMgmtV1SkuRulesGetRequest {
	return ApiApiAccountsMgmtV1SkuRulesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return SkuRulesList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkuRulesGetExecute(r ApiApiAccountsMgmtV1SkuRulesGetRequest) (SkuRulesList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SkuRulesList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SkuRulesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/sku_rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SkuRulesIdDeleteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
}


func (r ApiApiAccountsMgmtV1SkuRulesIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SkuRulesIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1SkuRulesIdDelete Delete a sku rule
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SkuRulesIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkuRulesIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1SkuRulesIdDeleteRequest {
	return ApiApiAccountsMgmtV1SkuRulesIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkuRulesIdDeleteExecute(r ApiApiAccountsMgmtV1SkuRulesIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SkuRulesIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/sku_rules/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SkuRulesIdGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
}


func (r ApiApiAccountsMgmtV1SkuRulesIdGetRequest) Execute() (SkuRules, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SkuRulesIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SkuRulesIdGet Get a sku rules by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SkuRulesIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkuRulesIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SkuRulesIdGetRequest {
	return ApiApiAccountsMgmtV1SkuRulesIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return SkuRules
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkuRulesIdGetExecute(r ApiApiAccountsMgmtV1SkuRulesIdGetRequest) (SkuRules, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SkuRules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SkuRulesIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/sku_rules/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SkuRulesIdPatchRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	skuRules *SkuRules
}

func (r ApiApiAccountsMgmtV1SkuRulesIdPatchRequest) SkuRules(skuRules SkuRules) ApiApiAccountsMgmtV1SkuRulesIdPatchRequest {
	r.skuRules = &skuRules
	return r
}

func (r ApiApiAccountsMgmtV1SkuRulesIdPatchRequest) Execute() (SkuRules, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SkuRulesIdPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1SkuRulesIdPatch Update a sku rule
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SkuRulesIdPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkuRulesIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1SkuRulesIdPatchRequest {
	return ApiApiAccountsMgmtV1SkuRulesIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return SkuRules
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkuRulesIdPatchExecute(r ApiApiAccountsMgmtV1SkuRulesIdPatchRequest) (SkuRules, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SkuRules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SkuRulesIdPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/sku_rules/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.skuRules == nil {
		return localVarReturnValue, nil, reportError("skuRules is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.skuRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SkuRulesPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	skuRules *SkuRules
}

func (r ApiApiAccountsMgmtV1SkuRulesPostRequest) SkuRules(skuRules SkuRules) ApiApiAccountsMgmtV1SkuRulesPostRequest {
	r.skuRules = &skuRules
	return r
}

func (r ApiApiAccountsMgmtV1SkuRulesPostRequest) Execute() (SkuRules, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SkuRulesPostExecute(r)
}

/*
 * ApiAccountsMgmtV1SkuRulesPost Create a new sku rule
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1SkuRulesPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkuRulesPost(ctx _context.Context) ApiApiAccountsMgmtV1SkuRulesPostRequest {
	return ApiApiAccountsMgmtV1SkuRulesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return SkuRules
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkuRulesPostExecute(r ApiApiAccountsMgmtV1SkuRulesPostRequest) (SkuRules, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SkuRules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SkuRulesPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/sku_rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.skuRules == nil {
		return localVarReturnValue, nil, reportError("skuRules is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.skuRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SkusGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	search *string
}

func (r ApiApiAccountsMgmtV1SkusGetRequest) Search(search string) ApiApiAccountsMgmtV1SkusGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1SkusGetRequest) Execute() (SkuList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SkusGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SkusGet Returns a list of UHC product SKUs
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1SkusGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkusGet(ctx _context.Context) ApiApiAccountsMgmtV1SkusGetRequest {
	return ApiApiAccountsMgmtV1SkusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return SkuList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkusGetExecute(r ApiApiAccountsMgmtV1SkusGetRequest) (SkuList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SkuList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SkusGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/skus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SkusIdGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
}


func (r ApiApiAccountsMgmtV1SkusIdGetRequest) Execute() (SKU, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SkusIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SkusIdGet Get a sku by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SkusIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkusIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SkusIdGetRequest {
	return ApiApiAccountsMgmtV1SkusIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return SKU
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkusIdGetExecute(r ApiApiAccountsMgmtV1SkusIdGetRequest) (SKU, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SKU
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SkusIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/skus/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	page *int32
	size *int32
	search *string
	fetchAccounts *bool
	fetchLabels *bool
	fetchCapabilities *bool
	fields *string
	orderBy *string
	labels *string
}

func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) Page(page int32) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) Size(size int32) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) Search(search string) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) FetchAccounts(fetchAccounts bool) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	r.fetchAccounts = &fetchAccounts
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) FetchLabels(fetchLabels bool) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	r.fetchLabels = &fetchLabels
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) FetchCapabilities(fetchCapabilities bool) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	r.fetchCapabilities = &fetchCapabilities
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) Fields(fields string) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	r.fields = &fields
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	r.orderBy = &orderBy
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) Labels(labels string) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	r.labels = &labels
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) Execute() (SubscriptionList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsGet Returns a list of subscriptions
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1SubscriptionsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsGet(ctx _context.Context) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	return ApiApiAccountsMgmtV1SubscriptionsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return SubscriptionList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsGetExecute(r ApiApiAccountsMgmtV1SubscriptionsGetRequest) (SubscriptionList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SubscriptionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.fetchAccounts != nil {
		localVarQueryParams.Add("fetchAccounts", parameterToString(*r.fetchAccounts, ""))
	}
	if r.fetchLabels != nil {
		localVarQueryParams.Add("fetchLabels", parameterToString(*r.fetchLabels, ""))
	}
	if r.fetchCapabilities != nil {
		localVarQueryParams.Add("fetchCapabilities", parameterToString(*r.fetchCapabilities, ""))
	}
	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	if r.labels != nil {
		localVarQueryParams.Add("labels", parameterToString(*r.labels, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["AccessToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdDeleteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
}


func (r ApiApiAccountsMgmtV1SubscriptionsIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdDelete Deletes a subscription by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SubscriptionsIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdDeleteRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdDeleteExecute(r ApiApiAccountsMgmtV1SubscriptionsIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	fetchAccounts *bool
	fetchLabels *bool
	fetchCapabilities *bool
	fetchCpuAndSocket *bool
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdGetRequest) FetchAccounts(fetchAccounts bool) ApiApiAccountsMgmtV1SubscriptionsIdGetRequest {
	r.fetchAccounts = &fetchAccounts
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsIdGetRequest) FetchLabels(fetchLabels bool) ApiApiAccountsMgmtV1SubscriptionsIdGetRequest {
	r.fetchLabels = &fetchLabels
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsIdGetRequest) FetchCapabilities(fetchCapabilities bool) ApiApiAccountsMgmtV1SubscriptionsIdGetRequest {
	r.fetchCapabilities = &fetchCapabilities
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsIdGetRequest) FetchCpuAndSocket(fetchCpuAndSocket bool) ApiApiAccountsMgmtV1SubscriptionsIdGetRequest {
	r.fetchCpuAndSocket = &fetchCpuAndSocket
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdGetRequest) Execute() (Subscription, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdGet Get a subscription by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SubscriptionsIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdGetRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return Subscription
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdGetRequest) (Subscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fetchAccounts != nil {
		localVarQueryParams.Add("fetchAccounts", parameterToString(*r.fetchAccounts, ""))
	}
	if r.fetchLabels != nil {
		localVarQueryParams.Add("fetchLabels", parameterToString(*r.fetchLabels, ""))
	}
	if r.fetchCapabilities != nil {
		localVarQueryParams.Add("fetchCapabilities", parameterToString(*r.fetchCapabilities, ""))
	}
	if r.fetchCpuAndSocket != nil {
		localVarQueryParams.Add("fetchCpuAndSocket", parameterToString(*r.fetchCpuAndSocket, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	page *int32
	size *int32
	search *string
	orderBy *string
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest) Page(page int32) ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest) Size(size int32) ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest) Search(search string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest) Execute() (LabelList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdLabelsGet Returns a list of labels
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return LabelList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest) (LabelList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LabelList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	key string
}


func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdLabelsKeyDelete Delete a label
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param key The key of the label
 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsKeyDelete(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		key: key,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsKeyDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	key string
}


func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetRequest) Execute() (Label, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdLabelsKeyGet Get subscription labels by label key
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param key The key of the label
 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsKeyGet(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		key: key,
	}
}

/*
 * Execute executes the request
 * @return Label
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetRequest) (Label, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Label
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsKeyGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	key string
	label *Label
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest) Label(label Label) ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest {
	r.label = &label
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest) Execute() (Label, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatch Create a new label or update an existing label
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param key The key of the label
 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatch(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		key: key,
	}
}

/*
 * Execute executes the request
 * @return Label
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest) (Label, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Label
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.label == nil {
		return localVarReturnValue, nil, reportError("label is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.label
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	label *Label
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest) Label(label Label) ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest {
	r.label = &label
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest) Execute() (Label, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdLabelsPost Create a new label or update an existing label
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return Label
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsPostExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest) (Label, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Label
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.label == nil {
		return localVarReturnValue, nil, reportError("label is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.label
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	metricName string
	search *string
	fields *string
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGetRequest) Search(search string) ApiApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGetRequest) Fields(fields string) ApiApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGetRequest {
	r.fields = &fields
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGetRequest) Execute() (SubscriptionMetricList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGet Get subscription's metrics by metric name
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param metricName The name of the metric
 * @return ApiApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGet(ctx _context.Context, id string, metricName string) ApiApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGetRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		metricName: metricName,
	}
}

/*
 * Execute executes the request
 * @return SubscriptionMetricList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGetRequest) (SubscriptionMetricList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SubscriptionMetricList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdMetricsMetricNameGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}/metrics/{metric_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric_name"+"}", _neturl.PathEscape(parameterToString(r.metricName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	notificationRequest *NotificationRequest
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest) NotificationRequest(notificationRequest NotificationRequest) ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest {
	r.notificationRequest = &notificationRequest
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdNotifyPostExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdNotifyPost Notify the owner of a subscription
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdNotifyPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdNotifyPostExecute(r ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdNotifyPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}/notify"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.notificationRequest == nil {
		return nil, reportError("notificationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	subscriptionPatchRequest *SubscriptionPatchRequest
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest) SubscriptionPatchRequest(subscriptionPatchRequest SubscriptionPatchRequest) ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest {
	r.subscriptionPatchRequest = &subscriptionPatchRequest
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest) Execute() (Subscription, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdPatch Update a subscription
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return Subscription
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdPatchExecute(r ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest) (Subscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.subscriptionPatchRequest == nil {
		return localVarReturnValue, nil, reportError("subscriptionPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscriptionPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	page *int32
	size *int32
	search *string
	orderBy *string
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest) Page(page int32) ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest) Size(size int32) ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest) Search(search string) ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest) Execute() (ReservedResourceList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdReservedResourcesGet Returns a list of reserved resources
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdReservedResourcesGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return ReservedResourceList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest) (ReservedResourceList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReservedResourceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdReservedResourcesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}/reserved_resources"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	page *int32
	size *int32
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest) Page(page int32) ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest) Size(size int32) ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdSupportCasesGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdSupportCasesGet Returns a list of open support creates opened against the external cluster id of this subscrption
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdSupportCasesGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdSupportCasesGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdSupportCasesGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}/support_cases"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subscriptionCreateRequest *SubscriptionCreateRequest
}

func (r ApiApiAccountsMgmtV1SubscriptionsPostRequest) SubscriptionCreateRequest(subscriptionCreateRequest SubscriptionCreateRequest) ApiApiAccountsMgmtV1SubscriptionsPostRequest {
	r.subscriptionCreateRequest = &subscriptionCreateRequest
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsPostRequest) Execute() (Subscription, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsPost Create a new subscription
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1SubscriptionsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsPost(ctx _context.Context) ApiApiAccountsMgmtV1SubscriptionsPostRequest {
	return ApiApiAccountsMgmtV1SubscriptionsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return Subscription
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsPostExecute(r ApiApiAccountsMgmtV1SubscriptionsPostRequest) (Subscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.subscriptionCreateRequest == nil {
		return localVarReturnValue, nil, reportError("subscriptionCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscriptionCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subId string
	accountId string
}


func (r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDelete Deletes a notification contact by subscription and account id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subId The id of subscription
 * @param accountId The id of account
 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDelete(ctx _context.Context, subId string, accountId string) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteRequest {
	return ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		subId: subId,
		accountId: accountId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{subId}/notification_contacts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"subId"+"}", _neturl.PathEscape(parameterToString(r.subId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", _neturl.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subId string
	page *int32
	size *int32
	search *string
	fields *string
	orderBy *string
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest) Page(page int32) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest) Size(size int32) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest) Search(search string) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest) Fields(fields string) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest {
	r.fields = &fields
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest) Execute() (AccountList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGet Returns a list of notification contacts for the given subscription
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subId The id of subscription
 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGet(ctx _context.Context, subId string) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest {
	return ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest{
		ApiService: a,
		ctx: ctx,
		subId: subId,
	}
}

/*
 * Execute executes the request
 * @return AccountList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest) (AccountList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccountList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{subId}/notification_contacts"
	localVarPath = strings.Replace(localVarPath, "{"+"subId"+"}", _neturl.PathEscape(parameterToString(r.subId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subId string
	notificationContactCreateRequest *NotificationContactCreateRequest
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest) NotificationContactCreateRequest(notificationContactCreateRequest NotificationContactCreateRequest) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest {
	r.notificationContactCreateRequest = &notificationContactCreateRequest
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest) Execute() (Account, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPost Add an account as a notification contact to this subscription
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subId The id of subscription
 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPost(ctx _context.Context, subId string) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest {
	return ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest{
		ApiService: a,
		ctx: ctx,
		subId: subId,
	}
}

/*
 * Execute executes the request
 * @return Account
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest) (Account, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{subId}/notification_contacts"
	localVarPath = strings.Replace(localVarPath, "{"+"subId"+"}", _neturl.PathEscape(parameterToString(r.subId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.notificationContactCreateRequest == nil {
		return localVarReturnValue, nil, reportError("notificationContactCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationContactCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdDeleteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subId string
	reservedResourceId string
}


func (r ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdDelete Delete reserved resources by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subId The id of subscription
 * @param reservedResourceId The id of reserved resource
 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdDelete(ctx _context.Context, subId string, reservedResourceId string) ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdDeleteRequest {
	return ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		subId: subId,
		reservedResourceId: reservedResourceId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdDeleteExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{subId}/reserved_resources/{reservedResourceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"subId"+"}", _neturl.PathEscape(parameterToString(r.subId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservedResourceId"+"}", _neturl.PathEscape(parameterToString(r.reservedResourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subId string
	reservedResourceId string
}


func (r ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetRequest) Execute() (ReservedResource, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGet Get reserved resources by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subId The id of subscription
 * @param reservedResourceId The id of reserved resource
 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGet(ctx _context.Context, subId string, reservedResourceId string) ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetRequest {
	return ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetRequest{
		ApiService: a,
		ctx: ctx,
		subId: subId,
		reservedResourceId: reservedResourceId,
	}
}

/*
 * Execute executes the request
 * @return ReservedResource
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetRequest) (ReservedResource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReservedResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{subId}/reserved_resources/{reservedResourceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"subId"+"}", _neturl.PathEscape(parameterToString(r.subId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservedResourceId"+"}", _neturl.PathEscape(parameterToString(r.reservedResourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatchRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subId string
	reservedResourceId string
	reservedResourcePatchRequest *ReservedResourcePatchRequest
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatchRequest) ReservedResourcePatchRequest(reservedResourcePatchRequest ReservedResourcePatchRequest) ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatchRequest {
	r.reservedResourcePatchRequest = &reservedResourcePatchRequest
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatchRequest) Execute() (ReservedResource, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatch Update a reserved resource
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subId The id of subscription
 * @param reservedResourceId The id of reserved resource
 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatch(ctx _context.Context, subId string, reservedResourceId string) ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatchRequest {
	return ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		subId: subId,
		reservedResourceId: reservedResourceId,
	}
}

/*
 * Execute executes the request
 * @return ReservedResource
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatchExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatchRequest) (ReservedResource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReservedResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{subId}/reserved_resources/{reservedResourceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"subId"+"}", _neturl.PathEscape(parameterToString(r.subId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservedResourceId"+"}", _neturl.PathEscape(parameterToString(r.reservedResourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.reservedResourcePatchRequest == nil {
		return localVarReturnValue, nil, reportError("reservedResourcePatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reservedResourcePatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subId string
	page *int32
	size *int32
	search *string
	orderBy *string
	fetchAccounts *bool
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetRequest) Page(page int32) ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetRequest {
	r.page = &page
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetRequest) Size(size int32) ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetRequest {
	r.size = &size
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetRequest) Search(search string) ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetRequest {
	r.search = &search
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetRequest {
	r.orderBy = &orderBy
	return r
}
func (r ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetRequest) FetchAccounts(fetchAccounts bool) ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetRequest {
	r.fetchAccounts = &fetchAccounts
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetRequest) Execute() (SubscriptionRoleBindingList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGet Get subscription role bindings
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subId The id of subscription
 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGet(ctx _context.Context, subId string) ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetRequest {
	return ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetRequest{
		ApiService: a,
		ctx: ctx,
		subId: subId,
	}
}

/*
 * Execute executes the request
 * @return SubscriptionRoleBindingList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGetRequest) (SubscriptionRoleBindingList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SubscriptionRoleBindingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{subId}/role_bindings"
	localVarPath = strings.Replace(localVarPath, "{"+"subId"+"}", _neturl.PathEscape(parameterToString(r.subId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	if r.fetchAccounts != nil {
		localVarQueryParams.Add("fetchAccounts", parameterToString(*r.fetchAccounts, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdDeleteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	subId string
}


func (r ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdDelete Delete a subscription role binding
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param subId The id of subscription
 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdDelete(ctx _context.Context, id string, subId string) ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdDeleteRequest {
	return ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		subId: subId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdDeleteExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{subId}/role_bindings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subId"+"}", _neturl.PathEscape(parameterToString(r.subId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id string
	subId string
}


func (r ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdGetRequest) Execute() (SubscriptionRoleBinding, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdGet Get a Subscription Role Binding by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param subId The id of subscription
 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdGet(ctx _context.Context, id string, subId string) ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdGetRequest {
	return ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		subId: subId,
	}
}

/*
 * Execute executes the request
 * @return SubscriptionRoleBinding
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdGetExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdGetRequest) (SubscriptionRoleBinding, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SubscriptionRoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{subId}/role_bindings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subId"+"}", _neturl.PathEscape(parameterToString(r.subId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subId string
	subscriptionRoleBindingCreateRequest *SubscriptionRoleBindingCreateRequest
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPostRequest) SubscriptionRoleBindingCreateRequest(subscriptionRoleBindingCreateRequest SubscriptionRoleBindingCreateRequest) ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPostRequest {
	r.subscriptionRoleBindingCreateRequest = &subscriptionRoleBindingCreateRequest
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPostRequest) Execute() (SubscriptionRoleBinding, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPost Create a new subscription role binding
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subId The id of subscription
 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPost(ctx _context.Context, subId string) ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPostRequest {
	return ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPostRequest{
		ApiService: a,
		ctx: ctx,
		subId: subId,
	}
}

/*
 * Execute executes the request
 * @return SubscriptionRoleBinding
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPostExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPostRequest) (SubscriptionRoleBinding, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SubscriptionRoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsSubIdRoleBindingsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{subId}/role_bindings"
	localVarPath = strings.Replace(localVarPath, "{"+"subId"+"}", _neturl.PathEscape(parameterToString(r.subId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.subscriptionRoleBindingCreateRequest == nil {
		return localVarReturnValue, nil, reportError("subscriptionRoleBindingCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscriptionRoleBindingCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SupportCasesCaseIdDeleteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	caseId string
}


func (r ApiApiAccountsMgmtV1SupportCasesCaseIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SupportCasesCaseIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1SupportCasesCaseIdDelete Delete a support case
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param caseId The id of a support case
 * @return ApiApiAccountsMgmtV1SupportCasesCaseIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SupportCasesCaseIdDelete(ctx _context.Context, caseId string) ApiApiAccountsMgmtV1SupportCasesCaseIdDeleteRequest {
	return ApiApiAccountsMgmtV1SupportCasesCaseIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		caseId: caseId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SupportCasesCaseIdDeleteExecute(r ApiApiAccountsMgmtV1SupportCasesCaseIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SupportCasesCaseIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/support_cases/{caseId}"
	localVarPath = strings.Replace(localVarPath, "{"+"caseId"+"}", _neturl.PathEscape(parameterToString(r.caseId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SupportCasesPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	supportCasesRequest *SupportCasesRequest
}

func (r ApiApiAccountsMgmtV1SupportCasesPostRequest) SupportCasesRequest(supportCasesRequest SupportCasesRequest) ApiApiAccountsMgmtV1SupportCasesPostRequest {
	r.supportCasesRequest = &supportCasesRequest
	return r
}

func (r ApiApiAccountsMgmtV1SupportCasesPostRequest) Execute() (SupportCasesCreatedResponse, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SupportCasesPostExecute(r)
}

/*
 * ApiAccountsMgmtV1SupportCasesPost create a support case for the subscription
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1SupportCasesPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SupportCasesPost(ctx _context.Context) ApiApiAccountsMgmtV1SupportCasesPostRequest {
	return ApiApiAccountsMgmtV1SupportCasesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return SupportCasesCreatedResponse
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SupportCasesPostExecute(r ApiApiAccountsMgmtV1SupportCasesPostRequest) (SupportCasesCreatedResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SupportCasesCreatedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SupportCasesPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/support_cases"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.supportCasesRequest == nil {
		return localVarReturnValue, nil, reportError("supportCasesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.supportCasesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1TokenAuthorizationPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	tokenAuthorizationRequest *TokenAuthorizationRequest
}

func (r ApiApiAccountsMgmtV1TokenAuthorizationPostRequest) TokenAuthorizationRequest(tokenAuthorizationRequest TokenAuthorizationRequest) ApiApiAccountsMgmtV1TokenAuthorizationPostRequest {
	r.tokenAuthorizationRequest = &tokenAuthorizationRequest
	return r
}

func (r ApiApiAccountsMgmtV1TokenAuthorizationPostRequest) Execute() (TokenAuthorizationResponse, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1TokenAuthorizationPostExecute(r)
}

/*
 * ApiAccountsMgmtV1TokenAuthorizationPost Finds the account owner of the provided token
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1TokenAuthorizationPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1TokenAuthorizationPost(ctx _context.Context) ApiApiAccountsMgmtV1TokenAuthorizationPostRequest {
	return ApiApiAccountsMgmtV1TokenAuthorizationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return TokenAuthorizationResponse
 */
func (a *DefaultApiService) ApiAccountsMgmtV1TokenAuthorizationPostExecute(r ApiApiAccountsMgmtV1TokenAuthorizationPostRequest) (TokenAuthorizationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TokenAuthorizationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1TokenAuthorizationPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/token_authorization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.tokenAuthorizationRequest == nil {
		return localVarReturnValue, nil, reportError("tokenAuthorizationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tokenAuthorizationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAuthorizationsV1AccessReviewPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	accessReview *AccessReview
}

func (r ApiApiAuthorizationsV1AccessReviewPostRequest) AccessReview(accessReview AccessReview) ApiApiAuthorizationsV1AccessReviewPostRequest {
	r.accessReview = &accessReview
	return r
}

func (r ApiApiAuthorizationsV1AccessReviewPostRequest) Execute() (AccessReviewResponse, *_nethttp.Response, error) {
	return r.ApiService.ApiAuthorizationsV1AccessReviewPostExecute(r)
}

/*
 * ApiAuthorizationsV1AccessReviewPost Review an account's access to perform an action on a particular resource or resource type
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAuthorizationsV1AccessReviewPostRequest
 */
func (a *DefaultApiService) ApiAuthorizationsV1AccessReviewPost(ctx _context.Context) ApiApiAuthorizationsV1AccessReviewPostRequest {
	return ApiApiAuthorizationsV1AccessReviewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return AccessReviewResponse
 */
func (a *DefaultApiService) ApiAuthorizationsV1AccessReviewPostExecute(r ApiApiAuthorizationsV1AccessReviewPostRequest) (AccessReviewResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccessReviewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAuthorizationsV1AccessReviewPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authorizations/v1/access_review"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.accessReview == nil {
		return localVarReturnValue, nil, reportError("accessReview is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accessReview
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAuthorizationsV1CapabilityReviewPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	capabilityReviewRequest *CapabilityReviewRequest
}

func (r ApiApiAuthorizationsV1CapabilityReviewPostRequest) CapabilityReviewRequest(capabilityReviewRequest CapabilityReviewRequest) ApiApiAuthorizationsV1CapabilityReviewPostRequest {
	r.capabilityReviewRequest = &capabilityReviewRequest
	return r
}

func (r ApiApiAuthorizationsV1CapabilityReviewPostRequest) Execute() (CapabilityReview, *_nethttp.Response, error) {
	return r.ApiService.ApiAuthorizationsV1CapabilityReviewPostExecute(r)
}

/*
 * ApiAuthorizationsV1CapabilityReviewPost Review an account's capabilities
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAuthorizationsV1CapabilityReviewPostRequest
 */
func (a *DefaultApiService) ApiAuthorizationsV1CapabilityReviewPost(ctx _context.Context) ApiApiAuthorizationsV1CapabilityReviewPostRequest {
	return ApiApiAuthorizationsV1CapabilityReviewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return CapabilityReview
 */
func (a *DefaultApiService) ApiAuthorizationsV1CapabilityReviewPostExecute(r ApiApiAuthorizationsV1CapabilityReviewPostRequest) (CapabilityReview, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CapabilityReview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAuthorizationsV1CapabilityReviewPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authorizations/v1/capability_review"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.capabilityReviewRequest == nil {
		return localVarReturnValue, nil, reportError("capabilityReviewRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.capabilityReviewRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAuthorizationsV1ExportControlReviewPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	exportControlReviewRequest *ExportControlReviewRequest
}

func (r ApiApiAuthorizationsV1ExportControlReviewPostRequest) ExportControlReviewRequest(exportControlReviewRequest ExportControlReviewRequest) ApiApiAuthorizationsV1ExportControlReviewPostRequest {
	r.exportControlReviewRequest = &exportControlReviewRequest
	return r
}

func (r ApiApiAuthorizationsV1ExportControlReviewPostRequest) Execute() (ExportControlReview, *_nethttp.Response, error) {
	return r.ApiService.ApiAuthorizationsV1ExportControlReviewPostExecute(r)
}

/*
 * ApiAuthorizationsV1ExportControlReviewPost Determine whether a user is restricted from downloading Red Hat software based on export control compliance. 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAuthorizationsV1ExportControlReviewPostRequest
 */
func (a *DefaultApiService) ApiAuthorizationsV1ExportControlReviewPost(ctx _context.Context) ApiApiAuthorizationsV1ExportControlReviewPostRequest {
	return ApiApiAuthorizationsV1ExportControlReviewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ExportControlReview
 */
func (a *DefaultApiService) ApiAuthorizationsV1ExportControlReviewPostExecute(r ApiApiAuthorizationsV1ExportControlReviewPostRequest) (ExportControlReview, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExportControlReview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAuthorizationsV1ExportControlReviewPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authorizations/v1/export_control_review"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.exportControlReviewRequest == nil {
		return localVarReturnValue, nil, reportError("exportControlReviewRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.exportControlReviewRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAuthorizationsV1FeatureReviewPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	featureReview *FeatureReview
}

func (r ApiApiAuthorizationsV1FeatureReviewPostRequest) FeatureReview(featureReview FeatureReview) ApiApiAuthorizationsV1FeatureReviewPostRequest {
	r.featureReview = &featureReview
	return r
}

func (r ApiApiAuthorizationsV1FeatureReviewPostRequest) Execute() (FeatureReviewResponse, *_nethttp.Response, error) {
	return r.ApiService.ApiAuthorizationsV1FeatureReviewPostExecute(r)
}

/*
 * ApiAuthorizationsV1FeatureReviewPost Review feature to perform an action on it such as toggle a feature on/off
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAuthorizationsV1FeatureReviewPostRequest
 */
func (a *DefaultApiService) ApiAuthorizationsV1FeatureReviewPost(ctx _context.Context) ApiApiAuthorizationsV1FeatureReviewPostRequest {
	return ApiApiAuthorizationsV1FeatureReviewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return FeatureReviewResponse
 */
func (a *DefaultApiService) ApiAuthorizationsV1FeatureReviewPostExecute(r ApiApiAuthorizationsV1FeatureReviewPostRequest) (FeatureReviewResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FeatureReviewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAuthorizationsV1FeatureReviewPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authorizations/v1/feature_review"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.featureReview == nil {
		return localVarReturnValue, nil, reportError("featureReview is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.featureReview
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAuthorizationsV1ResourceReviewPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	resourceReviewRequest *ResourceReviewRequest
	reduceClusterList *bool
}

func (r ApiApiAuthorizationsV1ResourceReviewPostRequest) ResourceReviewRequest(resourceReviewRequest ResourceReviewRequest) ApiApiAuthorizationsV1ResourceReviewPostRequest {
	r.resourceReviewRequest = &resourceReviewRequest
	return r
}
func (r ApiApiAuthorizationsV1ResourceReviewPostRequest) ReduceClusterList(reduceClusterList bool) ApiApiAuthorizationsV1ResourceReviewPostRequest {
	r.reduceClusterList = &reduceClusterList
	return r
}

func (r ApiApiAuthorizationsV1ResourceReviewPostRequest) Execute() (ResourceReview, *_nethttp.Response, error) {
	return r.ApiService.ApiAuthorizationsV1ResourceReviewPostExecute(r)
}

/*
 * ApiAuthorizationsV1ResourceReviewPost Obtain resource ids for resources an account may perform the specified action upon. Resource ids returned as [\"*\"] is shorthand for all ids.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAuthorizationsV1ResourceReviewPostRequest
 */
func (a *DefaultApiService) ApiAuthorizationsV1ResourceReviewPost(ctx _context.Context) ApiApiAuthorizationsV1ResourceReviewPostRequest {
	return ApiApiAuthorizationsV1ResourceReviewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ResourceReview
 */
func (a *DefaultApiService) ApiAuthorizationsV1ResourceReviewPostExecute(r ApiApiAuthorizationsV1ResourceReviewPostRequest) (ResourceReview, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceReview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAuthorizationsV1ResourceReviewPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authorizations/v1/resource_review"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.resourceReviewRequest == nil {
		return localVarReturnValue, nil, reportError("resourceReviewRequest is required and must be specified")
	}

	if r.reduceClusterList != nil {
		localVarQueryParams.Add("reduceClusterList", parameterToString(*r.reduceClusterList, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resourceReviewRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAuthorizationsV1SelfAccessReviewPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	selfAccessReview *SelfAccessReview
}

func (r ApiApiAuthorizationsV1SelfAccessReviewPostRequest) SelfAccessReview(selfAccessReview SelfAccessReview) ApiApiAuthorizationsV1SelfAccessReviewPostRequest {
	r.selfAccessReview = &selfAccessReview
	return r
}

func (r ApiApiAuthorizationsV1SelfAccessReviewPostRequest) Execute() (AccessReviewResponse, *_nethttp.Response, error) {
	return r.ApiService.ApiAuthorizationsV1SelfAccessReviewPostExecute(r)
}

/*
 * ApiAuthorizationsV1SelfAccessReviewPost Review your ability to perform an action on a particular resource or resource type
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAuthorizationsV1SelfAccessReviewPostRequest
 */
func (a *DefaultApiService) ApiAuthorizationsV1SelfAccessReviewPost(ctx _context.Context) ApiApiAuthorizationsV1SelfAccessReviewPostRequest {
	return ApiApiAuthorizationsV1SelfAccessReviewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return AccessReviewResponse
 */
func (a *DefaultApiService) ApiAuthorizationsV1SelfAccessReviewPostExecute(r ApiApiAuthorizationsV1SelfAccessReviewPostRequest) (AccessReviewResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccessReviewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAuthorizationsV1SelfAccessReviewPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authorizations/v1/self_access_review"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.selfAccessReview == nil {
		return localVarReturnValue, nil, reportError("selfAccessReview is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selfAccessReview
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAuthorizationsV1SelfFeatureReviewPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	selfFeatureReview *SelfFeatureReview
}

func (r ApiApiAuthorizationsV1SelfFeatureReviewPostRequest) SelfFeatureReview(selfFeatureReview SelfFeatureReview) ApiApiAuthorizationsV1SelfFeatureReviewPostRequest {
	r.selfFeatureReview = &selfFeatureReview
	return r
}

func (r ApiApiAuthorizationsV1SelfFeatureReviewPostRequest) Execute() (FeatureReviewResponse, *_nethttp.Response, error) {
	return r.ApiService.ApiAuthorizationsV1SelfFeatureReviewPostExecute(r)
}

/*
 * ApiAuthorizationsV1SelfFeatureReviewPost Review your ability to toggle a feature
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAuthorizationsV1SelfFeatureReviewPostRequest
 */
func (a *DefaultApiService) ApiAuthorizationsV1SelfFeatureReviewPost(ctx _context.Context) ApiApiAuthorizationsV1SelfFeatureReviewPostRequest {
	return ApiApiAuthorizationsV1SelfFeatureReviewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return FeatureReviewResponse
 */
func (a *DefaultApiService) ApiAuthorizationsV1SelfFeatureReviewPostExecute(r ApiApiAuthorizationsV1SelfFeatureReviewPostRequest) (FeatureReviewResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FeatureReviewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAuthorizationsV1SelfFeatureReviewPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authorizations/v1/self_feature_review"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.selfFeatureReview == nil {
		return localVarReturnValue, nil, reportError("selfFeatureReview is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selfFeatureReview
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAuthorizationsV1SelfResourceReviewPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	selfResourceReviewRequest *SelfResourceReviewRequest
	reduceClusterList *bool
}

func (r ApiApiAuthorizationsV1SelfResourceReviewPostRequest) SelfResourceReviewRequest(selfResourceReviewRequest SelfResourceReviewRequest) ApiApiAuthorizationsV1SelfResourceReviewPostRequest {
	r.selfResourceReviewRequest = &selfResourceReviewRequest
	return r
}
func (r ApiApiAuthorizationsV1SelfResourceReviewPostRequest) ReduceClusterList(reduceClusterList bool) ApiApiAuthorizationsV1SelfResourceReviewPostRequest {
	r.reduceClusterList = &reduceClusterList
	return r
}

func (r ApiApiAuthorizationsV1SelfResourceReviewPostRequest) Execute() (SelfResourceReview, *_nethttp.Response, error) {
	return r.ApiService.ApiAuthorizationsV1SelfResourceReviewPostExecute(r)
}

/*
 * ApiAuthorizationsV1SelfResourceReviewPost Obtain resource ids for resources you may perform the specified action upon. Resource ids returned as [\"*\"] is shorthand for all ids.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAuthorizationsV1SelfResourceReviewPostRequest
 */
func (a *DefaultApiService) ApiAuthorizationsV1SelfResourceReviewPost(ctx _context.Context) ApiApiAuthorizationsV1SelfResourceReviewPostRequest {
	return ApiApiAuthorizationsV1SelfResourceReviewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return SelfResourceReview
 */
func (a *DefaultApiService) ApiAuthorizationsV1SelfResourceReviewPostExecute(r ApiApiAuthorizationsV1SelfResourceReviewPostRequest) (SelfResourceReview, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SelfResourceReview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAuthorizationsV1SelfResourceReviewPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authorizations/v1/self_resource_review"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.selfResourceReviewRequest == nil {
		return localVarReturnValue, nil, reportError("selfResourceReviewRequest is required and must be specified")
	}

	if r.reduceClusterList != nil {
		localVarQueryParams.Add("reduceClusterList", parameterToString(*r.reduceClusterList, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selfResourceReviewRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAuthorizationsV1TermsReviewPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	termsReview *TermsReview
}

func (r ApiApiAuthorizationsV1TermsReviewPostRequest) TermsReview(termsReview TermsReview) ApiApiAuthorizationsV1TermsReviewPostRequest {
	r.termsReview = &termsReview
	return r
}

func (r ApiApiAuthorizationsV1TermsReviewPostRequest) Execute() (TermsReviewResponse, *_nethttp.Response, error) {
	return r.ApiService.ApiAuthorizationsV1TermsReviewPostExecute(r)
}

/*
 * ApiAuthorizationsV1TermsReviewPost Review an account's status of Terms
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAuthorizationsV1TermsReviewPostRequest
 */
func (a *DefaultApiService) ApiAuthorizationsV1TermsReviewPost(ctx _context.Context) ApiApiAuthorizationsV1TermsReviewPostRequest {
	return ApiApiAuthorizationsV1TermsReviewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return TermsReviewResponse
 */
func (a *DefaultApiService) ApiAuthorizationsV1TermsReviewPostExecute(r ApiApiAuthorizationsV1TermsReviewPostRequest) (TermsReviewResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TermsReviewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAuthorizationsV1TermsReviewPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authorizations/v1/terms_review"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.termsReview == nil {
		return localVarReturnValue, nil, reportError("termsReview is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.termsReview
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
