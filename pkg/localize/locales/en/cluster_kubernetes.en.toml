[cluster.kubernetes.log.info.statusMessage]
one = '''
This command will link your cluster with Cloud Services by creating custom resources and secrets.
In case of problems please execute "rhoas cluster status" to check if your cluster is properly configured
'''

[cluster.kubernetes.statusInfo]
one = '''
Connection Details:

Service Type:           {{.ServiceType}}
Service ID:             {{.ServiceID}}
Kubernetes Namespace:   {{.Namespace}}
Service Account Secret: {{.ServiceAccountSecretName}}
'''

[cluster.kubernetes.error.configNotFoundError]
one = 'missing kubeconfig file'

[cluster.kubernetes.error.loadConfigError]
one = 'failed to load kubeconfig'

[cluster.kubernetes.connect.input.confirm.message]
one = 'Do you want to continue?'

[cluster.kubernetes.connect.log.debug.cancellingConnect]
one = 'Cancelling cluster connection'

[cluster.kubernetes.createKafkaCR.error.marshalError]
one = 'could not marshal KafkaConnection to JSON object'

[cluster.kubernetes.createRegistryCR.error.marshalError]
one = 'could not marshal ServiceRegistryConnection to JSON object'

[cluster.kubernetes.createCR.log.info.customResourceCreated]
one = '{{.Resource}} resource "{{.Name}}" has been created'

[cluster.kubernetes.createRegistryCR.log.info.customResourceCreated]
one = 'ServiceRegistryConnection resource "{{.Name}}" has been created'

[cluster.kubernetes.watchForConnectionStatus.error.format]
one = 'invalid result from operator. Status object is not compatible with expected result from CLI.'

[cluster.kubernetes.watchForResourceStatus.error.status]
one = 'error when processing {{.Resource}}: %v'

[cluster.kubernetes.watchForResourceStatus.log.info.success]
one = '{{.Resource}} successfully installed on your cluster.'

[cluster.kubernetes.watchForResourceStatus.error.timeout]
one = 'process of watching {{.Resource}} timed out'

[cluster.kubernetes.watchForResourceStatus.log.info.wait]
one = '''
Waiting for status from {{.Resource}} resource.
Created {{.Resource}} can be already injected to your application.

To bind you need to have Service Binding Operator installed:
https://github.com/redhat-developer/service-binding-operator

You can bind {{.Resource}} to your application by executing "rhoas cluster bind" 
or directly in the OpenShift Console topology view.
'''

[cluster.kubernetes.watchForRegistryStatus.log.info.wait]
one = '''
Waiting for status from ServiceRegistryConnection resource.
Created ServiceRegistryConnection can be already injected to your application.

To bind you need to have Service Binding Operator installed:
https://github.com/redhat-developer/service-binding-operator

You can bind ServiceRegistryConnection to your application by executing "rhoas cluster bind" 
or directly in the OpenShift Console topology view.
'''

[cluster.kubernetes.serviceaccountsecret.error.createError]
one = 'could not create Service Account secret'

[cluster.kubernetes.tokensecret.log.info.found]
one = 'Access token already exist on the specified namespace'

[cluster.kubernetes.createTokenSecret.log.info.createSuccess]
one = 'Token Secret "{{.Name}}" created successfully'

[cluster.kubernetes.createSASecret.log.info.createSuccess]
one = 'Service Account Secret "{{.Name}}" created successfully'

[cluster.kubernetes.createTokenSecret.log.info.createFailed]
one = 'Creation of the "{{.Name}}" secret failed:'

[cluster.kubernetes.createServiceAccount.error.createError]
one = 'could not create service account'

[cluster.kubernetes.serviceaccountsecret.log.info.exist]
one = 'Service account secret already exist.'

[cluster.kubernetes.checkIfConnectionExist.existError]
one = 'KafkaConnection already exist'

[cluster.kubernetes.checkIfServiceRegistryConnectionExist.existError]
one = 'ServiceRegistryConnection already exist'
