/*
 * Account Management Service API
 *
 * Manage user subscriptions and clusters
 *
 * API version: 0.0.1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package amsclient

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type DefaultApi interface {

	/*
	 * ApiAccountsMgmtV1AccessTokenPost Return access token generated from registries in docker format
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1AccessTokenPostRequest
	 */
	ApiAccountsMgmtV1AccessTokenPost(ctx _context.Context) ApiApiAccountsMgmtV1AccessTokenPostRequest

	/*
	 * ApiAccountsMgmtV1AccessTokenPostExecute executes the request
	 * @return AccessTokenCfg
	 */
	ApiAccountsMgmtV1AccessTokenPostExecute(r ApiApiAccountsMgmtV1AccessTokenPostRequest) (AccessTokenCfg, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1AccountsGet Returns a list of accounts
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1AccountsGetRequest
	 */
	ApiAccountsMgmtV1AccountsGet(ctx _context.Context) ApiApiAccountsMgmtV1AccountsGetRequest

	/*
	 * ApiAccountsMgmtV1AccountsGetExecute executes the request
	 * @return AccountList
	 */
	ApiAccountsMgmtV1AccountsGetExecute(r ApiApiAccountsMgmtV1AccountsGetRequest) (AccountList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1AccountsIdGet Get an account by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1AccountsIdGetRequest
	 */
	ApiAccountsMgmtV1AccountsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1AccountsIdGetRequest

	/*
	 * ApiAccountsMgmtV1AccountsIdGetExecute executes the request
	 * @return Account
	 */
	ApiAccountsMgmtV1AccountsIdGetExecute(r ApiApiAccountsMgmtV1AccountsIdGetRequest) (Account, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsGet Returns a list of labels
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest
	 */
	ApiAccountsMgmtV1AccountsIdLabelsGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsGetExecute executes the request
	 * @return LabelList
	 */
	ApiAccountsMgmtV1AccountsIdLabelsGetExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest) (LabelList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsKeyDelete Delete a label
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param key The key of the label
	 * @return ApiApiAccountsMgmtV1AccountsIdLabelsKeyDeleteRequest
	 */
	ApiAccountsMgmtV1AccountsIdLabelsKeyDelete(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1AccountsIdLabelsKeyDeleteRequest

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsKeyDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1AccountsIdLabelsKeyDeleteExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsKeyDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsKeyGet Get subscription labels by label key
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param key The key of the label
	 * @return ApiApiAccountsMgmtV1AccountsIdLabelsKeyGetRequest
	 */
	ApiAccountsMgmtV1AccountsIdLabelsKeyGet(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1AccountsIdLabelsKeyGetRequest

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsKeyGetExecute executes the request
	 * @return Label
	 */
	ApiAccountsMgmtV1AccountsIdLabelsKeyGetExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsKeyGetRequest) (Label, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsKeyPatch Create a new label or update an existing label
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param key The key of the label
	 * @return ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest
	 */
	ApiAccountsMgmtV1AccountsIdLabelsKeyPatch(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsKeyPatchExecute executes the request
	 * @return Label
	 */
	ApiAccountsMgmtV1AccountsIdLabelsKeyPatchExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest) (Label, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsPost Create a new label or update an existing label
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest
	 */
	ApiAccountsMgmtV1AccountsIdLabelsPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest

	/*
	 * ApiAccountsMgmtV1AccountsIdLabelsPostExecute executes the request
	 * @return Label
	 */
	ApiAccountsMgmtV1AccountsIdLabelsPostExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest) (Label, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1AccountsIdPatch Update an account
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1AccountsIdPatchRequest
	 */
	ApiAccountsMgmtV1AccountsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1AccountsIdPatchRequest

	/*
	 * ApiAccountsMgmtV1AccountsIdPatchExecute executes the request
	 * @return Account
	 */
	ApiAccountsMgmtV1AccountsIdPatchExecute(r ApiApiAccountsMgmtV1AccountsIdPatchRequest) (Account, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1AccountsPost Create a new account
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1AccountsPostRequest
	 */
	ApiAccountsMgmtV1AccountsPost(ctx _context.Context) ApiApiAccountsMgmtV1AccountsPostRequest

	/*
	 * ApiAccountsMgmtV1AccountsPostExecute executes the request
	 * @return Account
	 */
	ApiAccountsMgmtV1AccountsPostExecute(r ApiApiAccountsMgmtV1AccountsPostRequest) (Account, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ClusterAuthorizationsPost Authorizes new cluster creation against an exsiting RH Subscription.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest
	 */
	ApiAccountsMgmtV1ClusterAuthorizationsPost(ctx _context.Context) ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest

	/*
	 * ApiAccountsMgmtV1ClusterAuthorizationsPostExecute executes the request
	 * @return ClusterAuthorizationResponse
	 */
	ApiAccountsMgmtV1ClusterAuthorizationsPostExecute(r ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest) (ClusterAuthorizationResponse, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ClusterRegistrationsPost Finds or creates a cluster registration with a registy credential token and cluster ID
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest
	 */
	ApiAccountsMgmtV1ClusterRegistrationsPost(ctx _context.Context) ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest

	/*
	 * ApiAccountsMgmtV1ClusterRegistrationsPostExecute executes the request
	 * @return ClusterRegistrationResponse
	 */
	ApiAccountsMgmtV1ClusterRegistrationsPostExecute(r ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest) (ClusterRegistrationResponse, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1CurrentAccountGet Get the authenticated account
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1CurrentAccountGetRequest
	 */
	ApiAccountsMgmtV1CurrentAccountGet(ctx _context.Context) ApiApiAccountsMgmtV1CurrentAccountGetRequest

	/*
	 * ApiAccountsMgmtV1CurrentAccountGetExecute executes the request
	 * @return Account
	 */
	ApiAccountsMgmtV1CurrentAccountGetExecute(r ApiApiAccountsMgmtV1CurrentAccountGetRequest) (Account, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ErrorsGet Returns a list of errors
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1ErrorsGetRequest
	 */
	ApiAccountsMgmtV1ErrorsGet(ctx _context.Context) ApiApiAccountsMgmtV1ErrorsGetRequest

	/*
	 * ApiAccountsMgmtV1ErrorsGetExecute executes the request
	 * @return ErrorList
	 */
	ApiAccountsMgmtV1ErrorsGetExecute(r ApiApiAccountsMgmtV1ErrorsGetRequest) (ErrorList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ErrorsIdGet Get an error by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1ErrorsIdGetRequest
	 */
	ApiAccountsMgmtV1ErrorsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1ErrorsIdGetRequest

	/*
	 * ApiAccountsMgmtV1ErrorsIdGetExecute executes the request
	 * @return Error
	 */
	ApiAccountsMgmtV1ErrorsIdGetExecute(r ApiApiAccountsMgmtV1ErrorsIdGetRequest) (Error, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1FeatureTogglesIdQueryPost Query a feature toggle by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest
	 */
	ApiAccountsMgmtV1FeatureTogglesIdQueryPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest

	/*
	 * ApiAccountsMgmtV1FeatureTogglesIdQueryPostExecute executes the request
	 * @return FeatureToggle
	 */
	ApiAccountsMgmtV1FeatureTogglesIdQueryPostExecute(r ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest) (FeatureToggle, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1LabelsGet Returns a list of labels
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1LabelsGetRequest
	 */
	ApiAccountsMgmtV1LabelsGet(ctx _context.Context) ApiApiAccountsMgmtV1LabelsGetRequest

	/*
	 * ApiAccountsMgmtV1LabelsGetExecute executes the request
	 * @return LabelList
	 */
	ApiAccountsMgmtV1LabelsGetExecute(r ApiApiAccountsMgmtV1LabelsGetRequest) (LabelList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1MetricsGet Returns a list of metrics
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1MetricsGetRequest
	 */
	ApiAccountsMgmtV1MetricsGet(ctx _context.Context) ApiApiAccountsMgmtV1MetricsGetRequest

	/*
	 * ApiAccountsMgmtV1MetricsGetExecute executes the request
	 * @return MetricsList
	 */
	ApiAccountsMgmtV1MetricsGetExecute(r ApiApiAccountsMgmtV1MetricsGetRequest) (MetricsList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1NotifyPost Notify the owner of cluster/subscription
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1NotifyPostRequest
	 */
	ApiAccountsMgmtV1NotifyPost(ctx _context.Context) ApiApiAccountsMgmtV1NotifyPostRequest

	/*
	 * ApiAccountsMgmtV1NotifyPostExecute executes the request
	 */
	ApiAccountsMgmtV1NotifyPostExecute(r ApiApiAccountsMgmtV1NotifyPostRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsGet Returns a list of organizations
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1OrganizationsGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsGet(ctx _context.Context) ApiApiAccountsMgmtV1OrganizationsGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsGetExecute executes the request
	 * @return OrganizationList
	 */
	ApiAccountsMgmtV1OrganizationsGetExecute(r ApiApiAccountsMgmtV1OrganizationsGetRequest) (OrganizationList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsIdGet Get an organization by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1OrganizationsIdGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsIdGetExecute executes the request
	 * @return Organization
	 */
	ApiAccountsMgmtV1OrganizationsIdGetExecute(r ApiApiAccountsMgmtV1OrganizationsIdGetRequest) (Organization, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsGet Returns a list of labels
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsGetExecute executes the request
	 * @return LabelList
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsGetExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest) (LabelList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsKeyDelete Delete a label
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param key The key of the label
	 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteRequest
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsKeyDelete(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsKeyGet Get subscription labels by label key
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param key The key of the label
	 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsKeyGet(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsKeyGetExecute executes the request
	 * @return Label
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsKeyGetExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyGetRequest) (Label, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsKeyPatch Create a new label or update an existing label
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param key The key of the label
	 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsKeyPatch(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchExecute executes the request
	 * @return Label
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest) (Label, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsPost Create a new label or update an existing label
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsIdLabelsPostExecute executes the request
	 * @return Label
	 */
	ApiAccountsMgmtV1OrganizationsIdLabelsPostExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest) (Label, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsIdPatch Update an organization
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1OrganizationsIdPatchRequest
	 */
	ApiAccountsMgmtV1OrganizationsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdPatchRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsIdPatchExecute executes the request
	 * @return Organization
	 */
	ApiAccountsMgmtV1OrganizationsIdPatchExecute(r ApiApiAccountsMgmtV1OrganizationsIdPatchRequest) (Organization, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsIdSummaryDashboardGet Returns a summary of organizations clusters based on metrics
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsIdSummaryDashboardGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetExecute executes the request
	 * @return Summary
	 */
	ApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetExecute(r ApiApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetRequest) (Summary, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGet Returns a summary of quota cost
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGet(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGetExecute executes the request
	 * @return QuotaCostList
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGetRequest) (QuotaCostList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGet Returns a summary of resource quota
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGet(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGetExecute executes the request
	 * @return QuotaSummaryList
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGetRequest) (QuotaSummaryList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGet Returns a list of resource quota objects
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGet(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetExecute executes the request
	 * @return ResourceQuotaList
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest) (ResourceQuotaList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPost Create a new resource quota
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPost(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostExecute executes the request
	 * @return ResourceQuota
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest) (ResourceQuota, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDelete Delete a resource quota
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @param quotaId The id of quota
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDelete(ctx _context.Context, orgId string, quotaId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGet Get a resource quota by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @param quotaId The id of quota
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGet(ctx _context.Context, orgId string, quotaId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetExecute executes the request
	 * @return ResourceQuota
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetRequest) (ResourceQuota, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatch Update a resource quota
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param orgId The id of organization
	 * @param quotaId The id of quota
	 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatch(ctx _context.Context, orgId string, quotaId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchExecute executes the request
	 * @return ResourceQuota
	 */
	ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest) (ResourceQuota, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1OrganizationsPost Create a new organization
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1OrganizationsPostRequest
	 */
	ApiAccountsMgmtV1OrganizationsPost(ctx _context.Context) ApiApiAccountsMgmtV1OrganizationsPostRequest

	/*
	 * ApiAccountsMgmtV1OrganizationsPostExecute executes the request
	 * @return Organization
	 */
	ApiAccountsMgmtV1OrganizationsPostExecute(r ApiApiAccountsMgmtV1OrganizationsPostRequest) (Organization, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1PlansGet Get all plans
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1PlansGetRequest
	 */
	ApiAccountsMgmtV1PlansGet(ctx _context.Context) ApiApiAccountsMgmtV1PlansGetRequest

	/*
	 * ApiAccountsMgmtV1PlansGetExecute executes the request
	 * @return PlanList
	 */
	ApiAccountsMgmtV1PlansGetExecute(r ApiApiAccountsMgmtV1PlansGetRequest) (PlanList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1PlansIdGet Get a plan by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1PlansIdGetRequest
	 */
	ApiAccountsMgmtV1PlansIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1PlansIdGetRequest

	/*
	 * ApiAccountsMgmtV1PlansIdGetExecute executes the request
	 * @return Plan
	 */
	ApiAccountsMgmtV1PlansIdGetExecute(r ApiApiAccountsMgmtV1PlansIdGetRequest) (Plan, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1PullSecretsExternalResourceIdDelete Delete a pull secret
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param externalResourceId The external resource id of record
	 * @return ApiApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteRequest
	 */
	ApiAccountsMgmtV1PullSecretsExternalResourceIdDelete(ctx _context.Context, externalResourceId string) ApiApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteExecute(r ApiApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1PullSecretsPost Return access token generated from registries in docker format
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1PullSecretsPostRequest
	 */
	ApiAccountsMgmtV1PullSecretsPost(ctx _context.Context) ApiApiAccountsMgmtV1PullSecretsPostRequest

	/*
	 * ApiAccountsMgmtV1PullSecretsPostExecute executes the request
	 * @return AccessTokenCfg
	 */
	ApiAccountsMgmtV1PullSecretsPostExecute(r ApiApiAccountsMgmtV1PullSecretsPostRequest) (AccessTokenCfg, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RegistriesGet Returns a list of registries
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1RegistriesGetRequest
	 */
	ApiAccountsMgmtV1RegistriesGet(ctx _context.Context) ApiApiAccountsMgmtV1RegistriesGetRequest

	/*
	 * ApiAccountsMgmtV1RegistriesGetExecute executes the request
	 * @return RegistryList
	 */
	ApiAccountsMgmtV1RegistriesGetExecute(r ApiApiAccountsMgmtV1RegistriesGetRequest) (RegistryList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RegistriesIdGet Get an registry by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1RegistriesIdGetRequest
	 */
	ApiAccountsMgmtV1RegistriesIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1RegistriesIdGetRequest

	/*
	 * ApiAccountsMgmtV1RegistriesIdGetExecute executes the request
	 * @return Registry
	 */
	ApiAccountsMgmtV1RegistriesIdGetExecute(r ApiApiAccountsMgmtV1RegistriesIdGetRequest) (Registry, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsGet Method for ApiAccountsMgmtV1RegistryCredentialsGet
	 * List Registry Credentials
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1RegistryCredentialsGetRequest
	 */
	ApiAccountsMgmtV1RegistryCredentialsGet(ctx _context.Context) ApiApiAccountsMgmtV1RegistryCredentialsGetRequest

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsGetExecute executes the request
	 * @return RegistryCredentialList
	 */
	ApiAccountsMgmtV1RegistryCredentialsGetExecute(r ApiApiAccountsMgmtV1RegistryCredentialsGetRequest) (RegistryCredentialList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsIdDelete Delete a registry credential by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1RegistryCredentialsIdDeleteRequest
	 */
	ApiAccountsMgmtV1RegistryCredentialsIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1RegistryCredentialsIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1RegistryCredentialsIdDeleteExecute(r ApiApiAccountsMgmtV1RegistryCredentialsIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsIdGet Get a registry credentials by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1RegistryCredentialsIdGetRequest
	 */
	ApiAccountsMgmtV1RegistryCredentialsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1RegistryCredentialsIdGetRequest

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsIdGetExecute executes the request
	 * @return RegistryCredential
	 */
	ApiAccountsMgmtV1RegistryCredentialsIdGetExecute(r ApiApiAccountsMgmtV1RegistryCredentialsIdGetRequest) (RegistryCredential, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsIdPatch Update a registry credential
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest
	 */
	ApiAccountsMgmtV1RegistryCredentialsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsIdPatchExecute executes the request
	 * @return RegistryCredential
	 */
	ApiAccountsMgmtV1RegistryCredentialsIdPatchExecute(r ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest) (RegistryCredential, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsPost Request the creation of a registry credential
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1RegistryCredentialsPostRequest
	 */
	ApiAccountsMgmtV1RegistryCredentialsPost(ctx _context.Context) ApiApiAccountsMgmtV1RegistryCredentialsPostRequest

	/*
	 * ApiAccountsMgmtV1RegistryCredentialsPostExecute executes the request
	 * @return RegistryCredential
	 */
	ApiAccountsMgmtV1RegistryCredentialsPostExecute(r ApiApiAccountsMgmtV1RegistryCredentialsPostRequest) (RegistryCredential, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ReservedResourcesGet Returns a list of reserved resources
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1ReservedResourcesGetRequest
	 */
	ApiAccountsMgmtV1ReservedResourcesGet(ctx _context.Context) ApiApiAccountsMgmtV1ReservedResourcesGetRequest

	/*
	 * ApiAccountsMgmtV1ReservedResourcesGetExecute executes the request
	 * @return ReservedResourceList
	 */
	ApiAccountsMgmtV1ReservedResourcesGetExecute(r ApiApiAccountsMgmtV1ReservedResourcesGetRequest) (ReservedResourceList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1ResourceQuotaGet Returns a list of resource quota objects
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1ResourceQuotaGetRequest
	 */
	ApiAccountsMgmtV1ResourceQuotaGet(ctx _context.Context) ApiApiAccountsMgmtV1ResourceQuotaGetRequest

	/*
	 * ApiAccountsMgmtV1ResourceQuotaGetExecute executes the request
	 * @return ResourceQuotaList
	 */
	ApiAccountsMgmtV1ResourceQuotaGetExecute(r ApiApiAccountsMgmtV1ResourceQuotaGetRequest) (ResourceQuotaList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RoleBindingsGet Returns a list of role bindings
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1RoleBindingsGetRequest
	 */
	ApiAccountsMgmtV1RoleBindingsGet(ctx _context.Context) ApiApiAccountsMgmtV1RoleBindingsGetRequest

	/*
	 * ApiAccountsMgmtV1RoleBindingsGetExecute executes the request
	 * @return RoleBindingList
	 */
	ApiAccountsMgmtV1RoleBindingsGetExecute(r ApiApiAccountsMgmtV1RoleBindingsGetRequest) (RoleBindingList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RoleBindingsIdDelete Delete a role binding
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1RoleBindingsIdDeleteRequest
	 */
	ApiAccountsMgmtV1RoleBindingsIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1RoleBindingsIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1RoleBindingsIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1RoleBindingsIdDeleteExecute(r ApiApiAccountsMgmtV1RoleBindingsIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RoleBindingsIdGet Get a role binding
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1RoleBindingsIdGetRequest
	 */
	ApiAccountsMgmtV1RoleBindingsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1RoleBindingsIdGetRequest

	/*
	 * ApiAccountsMgmtV1RoleBindingsIdGetExecute executes the request
	 * @return RoleBinding
	 */
	ApiAccountsMgmtV1RoleBindingsIdGetExecute(r ApiApiAccountsMgmtV1RoleBindingsIdGetRequest) (RoleBinding, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RoleBindingsIdPatch Update a role binding
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest
	 */
	ApiAccountsMgmtV1RoleBindingsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest

	/*
	 * ApiAccountsMgmtV1RoleBindingsIdPatchExecute executes the request
	 * @return RoleBinding
	 */
	ApiAccountsMgmtV1RoleBindingsIdPatchExecute(r ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest) (RoleBinding, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RoleBindingsPost Create a new role binding
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1RoleBindingsPostRequest
	 */
	ApiAccountsMgmtV1RoleBindingsPost(ctx _context.Context) ApiApiAccountsMgmtV1RoleBindingsPostRequest

	/*
	 * ApiAccountsMgmtV1RoleBindingsPostExecute executes the request
	 * @return RoleBinding
	 */
	ApiAccountsMgmtV1RoleBindingsPostExecute(r ApiApiAccountsMgmtV1RoleBindingsPostRequest) (RoleBinding, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RolesGet Returns a list of roles
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1RolesGetRequest
	 */
	ApiAccountsMgmtV1RolesGet(ctx _context.Context) ApiApiAccountsMgmtV1RolesGetRequest

	/*
	 * ApiAccountsMgmtV1RolesGetExecute executes the request
	 * @return RoleList
	 */
	ApiAccountsMgmtV1RolesGetExecute(r ApiApiAccountsMgmtV1RolesGetRequest) (RoleList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1RolesIdGet Get a role by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1RolesIdGetRequest
	 */
	ApiAccountsMgmtV1RolesIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1RolesIdGetRequest

	/*
	 * ApiAccountsMgmtV1RolesIdGetExecute executes the request
	 * @return Role
	 */
	ApiAccountsMgmtV1RolesIdGetExecute(r ApiApiAccountsMgmtV1RolesIdGetRequest) (Role, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SkuRulesGet Returns a list of UHC product SKU Rules
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1SkuRulesGetRequest
	 */
	ApiAccountsMgmtV1SkuRulesGet(ctx _context.Context) ApiApiAccountsMgmtV1SkuRulesGetRequest

	/*
	 * ApiAccountsMgmtV1SkuRulesGetExecute executes the request
	 * @return SkuRulesList
	 */
	ApiAccountsMgmtV1SkuRulesGetExecute(r ApiApiAccountsMgmtV1SkuRulesGetRequest) (SkuRulesList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SkuRulesIdGet Get a sku rules by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SkuRulesIdGetRequest
	 */
	ApiAccountsMgmtV1SkuRulesIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SkuRulesIdGetRequest

	/*
	 * ApiAccountsMgmtV1SkuRulesIdGetExecute executes the request
	 * @return SkuRules
	 */
	ApiAccountsMgmtV1SkuRulesIdGetExecute(r ApiApiAccountsMgmtV1SkuRulesIdGetRequest) (SkuRules, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SkusGet Returns a list of UHC product SKUs
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1SkusGetRequest
	 */
	ApiAccountsMgmtV1SkusGet(ctx _context.Context) ApiApiAccountsMgmtV1SkusGetRequest

	/*
	 * ApiAccountsMgmtV1SkusGetExecute executes the request
	 * @return SkuList
	 */
	ApiAccountsMgmtV1SkusGetExecute(r ApiApiAccountsMgmtV1SkusGetRequest) (SkuList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SkusIdGet Get a sku by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SkusIdGetRequest
	 */
	ApiAccountsMgmtV1SkusIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SkusIdGetRequest

	/*
	 * ApiAccountsMgmtV1SkusIdGetExecute executes the request
	 * @return SKU
	 */
	ApiAccountsMgmtV1SkusIdGetExecute(r ApiApiAccountsMgmtV1SkusIdGetRequest) (SKU, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsGet Returns a list of subscriptions
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1SubscriptionsGetRequest
	 */
	ApiAccountsMgmtV1SubscriptionsGet(ctx _context.Context) ApiApiAccountsMgmtV1SubscriptionsGetRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsGetExecute executes the request
	 * @return SubscriptionList
	 */
	ApiAccountsMgmtV1SubscriptionsGetExecute(r ApiApiAccountsMgmtV1SubscriptionsGetRequest) (SubscriptionList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdDelete Deletes a subscription by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdDeleteRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1SubscriptionsIdDeleteExecute(r ApiApiAccountsMgmtV1SubscriptionsIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdGet Get a subscription by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdGetRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdGetRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdGetExecute executes the request
	 * @return Subscription
	 */
	ApiAccountsMgmtV1SubscriptionsIdGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdGetRequest) (Subscription, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsGet Returns a list of labels
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsGetExecute executes the request
	 * @return LabelList
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest) (LabelList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsKeyDelete Delete a label
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param key The key of the label
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsKeyDelete(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsKeyGet Get subscription labels by label key
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param key The key of the label
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsKeyGet(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetExecute executes the request
	 * @return Label
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetRequest) (Label, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatch Create a new label or update an existing label
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @param key The key of the label
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatch(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchExecute executes the request
	 * @return Label
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest) (Label, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsPost Create a new label or update an existing label
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdLabelsPostExecute executes the request
	 * @return Label
	 */
	ApiAccountsMgmtV1SubscriptionsIdLabelsPostExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest) (Label, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdNotifyPost Notify the owner of a subscription
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdNotifyPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdNotifyPostExecute executes the request
	 */
	ApiAccountsMgmtV1SubscriptionsIdNotifyPostExecute(r ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdPatch Update a subscription
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdPatchExecute executes the request
	 * @return Subscription
	 */
	ApiAccountsMgmtV1SubscriptionsIdPatchExecute(r ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest) (Subscription, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdReservedResourcesGet Returns a list of reserved resources
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdReservedResourcesGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetExecute executes the request
	 * @return ReservedResourceList
	 */
	ApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest) (ReservedResourceList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdSupportCasesGet Returns a list of open support creates opened against the external cluster id of this subscrption
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The id of record
	 * @return ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest
	 */
	ApiAccountsMgmtV1SubscriptionsIdSupportCasesGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsIdSupportCasesGetExecute executes the request
	 */
	ApiAccountsMgmtV1SubscriptionsIdSupportCasesGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsPost Create a new subscription
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1SubscriptionsPostRequest
	 */
	ApiAccountsMgmtV1SubscriptionsPost(ctx _context.Context) ApiApiAccountsMgmtV1SubscriptionsPostRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsPostExecute executes the request
	 * @return Subscription
	 */
	ApiAccountsMgmtV1SubscriptionsPostExecute(r ApiApiAccountsMgmtV1SubscriptionsPostRequest) (Subscription, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDelete Deletes a notification contact by subscription and account id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param subId The id of subscription
	 * @param accountId The id of account
	 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteRequest
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDelete(ctx _context.Context, subId string, accountId string) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGet Returns a list of notification contacts for the given subscription
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param subId The id of subscription
	 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGet(ctx _context.Context, subId string) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetExecute executes the request
	 * @return AccountList
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest) (AccountList, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPost Add an account as a notification contact to this subscription
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param subId The id of subscription
	 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPost(ctx _context.Context, subId string) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostExecute executes the request
	 * @return Account
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest) (Account, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGet Get reserved resources by id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param subId The id of subscription
	 * @param reservedResourceId The id of reserved resource
	 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetRequest
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGet(ctx _context.Context, subId string, reservedResourceId string) ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetRequest

	/*
	 * ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetExecute executes the request
	 * @return ReservedResource
	 */
	ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetRequest) (ReservedResource, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SupportCasesCaseIdDelete Delete a support case
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param caseId The id of a support case
	 * @return ApiApiAccountsMgmtV1SupportCasesCaseIdDeleteRequest
	 */
	ApiAccountsMgmtV1SupportCasesCaseIdDelete(ctx _context.Context, caseId string) ApiApiAccountsMgmtV1SupportCasesCaseIdDeleteRequest

	/*
	 * ApiAccountsMgmtV1SupportCasesCaseIdDeleteExecute executes the request
	 */
	ApiAccountsMgmtV1SupportCasesCaseIdDeleteExecute(r ApiApiAccountsMgmtV1SupportCasesCaseIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1SupportCasesPost create a support case for the subscription
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1SupportCasesPostRequest
	 */
	ApiAccountsMgmtV1SupportCasesPost(ctx _context.Context) ApiApiAccountsMgmtV1SupportCasesPostRequest

	/*
	 * ApiAccountsMgmtV1SupportCasesPostExecute executes the request
	 * @return SupportCasesCreatedResponse
	 */
	ApiAccountsMgmtV1SupportCasesPostExecute(r ApiApiAccountsMgmtV1SupportCasesPostRequest) (SupportCasesCreatedResponse, *_nethttp.Response, error)

	/*
	 * ApiAccountsMgmtV1TokenAuthorizationPost Finds the account owner of the provided token
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAccountsMgmtV1TokenAuthorizationPostRequest
	 */
	ApiAccountsMgmtV1TokenAuthorizationPost(ctx _context.Context) ApiApiAccountsMgmtV1TokenAuthorizationPostRequest

	/*
	 * ApiAccountsMgmtV1TokenAuthorizationPostExecute executes the request
	 * @return TokenAuthorizationResponse
	 */
	ApiAccountsMgmtV1TokenAuthorizationPostExecute(r ApiApiAccountsMgmtV1TokenAuthorizationPostRequest) (TokenAuthorizationResponse, *_nethttp.Response, error)

	/*
	 * ApiAuthorizationsV1AccessReviewPost Review an account's access to perform an action on a particular resource or resource type
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAuthorizationsV1AccessReviewPostRequest
	 */
	ApiAuthorizationsV1AccessReviewPost(ctx _context.Context) ApiApiAuthorizationsV1AccessReviewPostRequest

	/*
	 * ApiAuthorizationsV1AccessReviewPostExecute executes the request
	 * @return AccessReviewResponse
	 */
	ApiAuthorizationsV1AccessReviewPostExecute(r ApiApiAuthorizationsV1AccessReviewPostRequest) (AccessReviewResponse, *_nethttp.Response, error)

	/*
	 * ApiAuthorizationsV1CapabilityReviewPost Review an account's capabilities
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAuthorizationsV1CapabilityReviewPostRequest
	 */
	ApiAuthorizationsV1CapabilityReviewPost(ctx _context.Context) ApiApiAuthorizationsV1CapabilityReviewPostRequest

	/*
	 * ApiAuthorizationsV1CapabilityReviewPostExecute executes the request
	 * @return CapabilityReview
	 */
	ApiAuthorizationsV1CapabilityReviewPostExecute(r ApiApiAuthorizationsV1CapabilityReviewPostRequest) (CapabilityReview, *_nethttp.Response, error)

	/*
	 * ApiAuthorizationsV1ExportControlReviewPost Determine whether a user is restricted from downloading Red Hat software based on export control compliance.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAuthorizationsV1ExportControlReviewPostRequest
	 */
	ApiAuthorizationsV1ExportControlReviewPost(ctx _context.Context) ApiApiAuthorizationsV1ExportControlReviewPostRequest

	/*
	 * ApiAuthorizationsV1ExportControlReviewPostExecute executes the request
	 * @return ExportControlReview
	 */
	ApiAuthorizationsV1ExportControlReviewPostExecute(r ApiApiAuthorizationsV1ExportControlReviewPostRequest) (ExportControlReview, *_nethttp.Response, error)

	/*
	 * ApiAuthorizationsV1ResourceReviewPost Obtain resource ids for resources an account may perform the specified action upon. Resource ids returned as [\"*\"] is shorthand for all ids.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAuthorizationsV1ResourceReviewPostRequest
	 */
	ApiAuthorizationsV1ResourceReviewPost(ctx _context.Context) ApiApiAuthorizationsV1ResourceReviewPostRequest

	/*
	 * ApiAuthorizationsV1ResourceReviewPostExecute executes the request
	 * @return ResourceReview
	 */
	ApiAuthorizationsV1ResourceReviewPostExecute(r ApiApiAuthorizationsV1ResourceReviewPostRequest) (ResourceReview, *_nethttp.Response, error)

	/*
	 * ApiAuthorizationsV1SelfAccessReviewPost Review your ability to perform an action on a particular resource or resource type
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAuthorizationsV1SelfAccessReviewPostRequest
	 */
	ApiAuthorizationsV1SelfAccessReviewPost(ctx _context.Context) ApiApiAuthorizationsV1SelfAccessReviewPostRequest

	/*
	 * ApiAuthorizationsV1SelfAccessReviewPostExecute executes the request
	 * @return AccessReviewResponse
	 */
	ApiAuthorizationsV1SelfAccessReviewPostExecute(r ApiApiAuthorizationsV1SelfAccessReviewPostRequest) (AccessReviewResponse, *_nethttp.Response, error)

	/*
	 * ApiAuthorizationsV1SelfResourceReviewPost Obtain resource ids for resources you may perform the specified action upon. Resource ids returned as [\"*\"] is shorthand for all ids.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAuthorizationsV1SelfResourceReviewPostRequest
	 */
	ApiAuthorizationsV1SelfResourceReviewPost(ctx _context.Context) ApiApiAuthorizationsV1SelfResourceReviewPostRequest

	/*
	 * ApiAuthorizationsV1SelfResourceReviewPostExecute executes the request
	 * @return SelfResourceReview
	 */
	ApiAuthorizationsV1SelfResourceReviewPostExecute(r ApiApiAuthorizationsV1SelfResourceReviewPostRequest) (SelfResourceReview, *_nethttp.Response, error)

	/*
	 * ApiAuthorizationsV1SelfTermsReviewPost Review your status of Terms
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAuthorizationsV1SelfTermsReviewPostRequest
	 */
	ApiAuthorizationsV1SelfTermsReviewPost(ctx _context.Context) ApiApiAuthorizationsV1SelfTermsReviewPostRequest

	/*
	 * ApiAuthorizationsV1SelfTermsReviewPostExecute executes the request
	 * @return TermsReviewResponse
	 */
	ApiAuthorizationsV1SelfTermsReviewPostExecute(r ApiApiAuthorizationsV1SelfTermsReviewPostRequest) (TermsReviewResponse, *_nethttp.Response, error)

	/*
	 * ApiAuthorizationsV1TermsReviewPost Review an account's status of Terms
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiAuthorizationsV1TermsReviewPostRequest
	 */
	ApiAuthorizationsV1TermsReviewPost(ctx _context.Context) ApiApiAuthorizationsV1TermsReviewPostRequest

	/*
	 * ApiAuthorizationsV1TermsReviewPostExecute executes the request
	 * @return TermsReviewResponse
	 */
	ApiAuthorizationsV1TermsReviewPostExecute(r ApiApiAuthorizationsV1TermsReviewPostRequest) (TermsReviewResponse, *_nethttp.Response, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiApiAccountsMgmtV1AccessTokenPostRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
}

func (r ApiApiAccountsMgmtV1AccessTokenPostRequest) Execute() (AccessTokenCfg, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1AccessTokenPostExecute(r)
}

/*
 * ApiAccountsMgmtV1AccessTokenPost Return access token generated from registries in docker format
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1AccessTokenPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccessTokenPost(ctx _context.Context) ApiApiAccountsMgmtV1AccessTokenPostRequest {
	return ApiApiAccountsMgmtV1AccessTokenPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return AccessTokenCfg
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccessTokenPostExecute(r ApiApiAccountsMgmtV1AccessTokenPostRequest) (AccessTokenCfg, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccessTokenCfg
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1AccessTokenPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/access_token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1AccountsGetRequest struct {
	ctx               _context.Context
	ApiService        DefaultApi
	page              *int32
	size              *int32
	search            *string
	orderBy           *string
	fields            *string
	fetchLabels       *bool
	fetchCapabilities *bool
}

func (r ApiApiAccountsMgmtV1AccountsGetRequest) Page(page int32) ApiApiAccountsMgmtV1AccountsGetRequest {
	r.page = &page
	return r
}

func (r ApiApiAccountsMgmtV1AccountsGetRequest) Size(size int32) ApiApiAccountsMgmtV1AccountsGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1AccountsGetRequest) Search(search string) ApiApiAccountsMgmtV1AccountsGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1AccountsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1AccountsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1AccountsGetRequest) Fields(fields string) ApiApiAccountsMgmtV1AccountsGetRequest {
	r.fields = &fields
	return r
}

func (r ApiApiAccountsMgmtV1AccountsGetRequest) FetchLabels(fetchLabels bool) ApiApiAccountsMgmtV1AccountsGetRequest {
	r.fetchLabels = &fetchLabels
	return r
}

func (r ApiApiAccountsMgmtV1AccountsGetRequest) FetchCapabilities(fetchCapabilities bool) ApiApiAccountsMgmtV1AccountsGetRequest {
	r.fetchCapabilities = &fetchCapabilities
	return r
}

func (r ApiApiAccountsMgmtV1AccountsGetRequest) Execute() (AccountList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1AccountsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1AccountsGet Returns a list of accounts
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1AccountsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsGet(ctx _context.Context) ApiApiAccountsMgmtV1AccountsGetRequest {
	return ApiApiAccountsMgmtV1AccountsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return AccountList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsGetExecute(r ApiApiAccountsMgmtV1AccountsGetRequest) (AccountList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccountList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1AccountsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	if r.fetchLabels != nil {
		localVarQueryParams.Add("fetchLabels", parameterToString(*r.fetchLabels, ""))
	}
	if r.fetchCapabilities != nil {
		localVarQueryParams.Add("fetchCapabilities", parameterToString(*r.fetchCapabilities, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1AccountsIdGetRequest struct {
	ctx               _context.Context
	ApiService        DefaultApi
	id                string
	fetchLabels       *bool
	fetchCapabilities *bool
}

func (r ApiApiAccountsMgmtV1AccountsIdGetRequest) FetchLabels(fetchLabels bool) ApiApiAccountsMgmtV1AccountsIdGetRequest {
	r.fetchLabels = &fetchLabels
	return r
}

func (r ApiApiAccountsMgmtV1AccountsIdGetRequest) FetchCapabilities(fetchCapabilities bool) ApiApiAccountsMgmtV1AccountsIdGetRequest {
	r.fetchCapabilities = &fetchCapabilities
	return r
}

func (r ApiApiAccountsMgmtV1AccountsIdGetRequest) Execute() (Account, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1AccountsIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1AccountsIdGet Get an account by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1AccountsIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1AccountsIdGetRequest {
	return ApiApiAccountsMgmtV1AccountsIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return Account
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdGetExecute(r ApiApiAccountsMgmtV1AccountsIdGetRequest) (Account, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1AccountsIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/accounts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fetchLabels != nil {
		localVarQueryParams.Add("fetchLabels", parameterToString(*r.fetchLabels, ""))
	}
	if r.fetchCapabilities != nil {
		localVarQueryParams.Add("fetchCapabilities", parameterToString(*r.fetchCapabilities, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
	page       *int32
	size       *int32
	search     *string
	orderBy    *string
}

func (r ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest) Page(page int32) ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest {
	r.page = &page
	return r
}

func (r ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest) Size(size int32) ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest) Search(search string) ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest) Execute() (LabelList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1AccountsIdLabelsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1AccountsIdLabelsGet Returns a list of labels
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest {
	return ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return LabelList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsGetExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsGetRequest) (LabelList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LabelList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1AccountsIdLabelsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/accounts/{id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1AccountsIdLabelsKeyDeleteRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
	key        string
}

func (r ApiApiAccountsMgmtV1AccountsIdLabelsKeyDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1AccountsIdLabelsKeyDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1AccountsIdLabelsKeyDelete Delete a label
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param key The key of the label
 * @return ApiApiAccountsMgmtV1AccountsIdLabelsKeyDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsKeyDelete(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1AccountsIdLabelsKeyDeleteRequest {
	return ApiApiAccountsMgmtV1AccountsIdLabelsKeyDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		key:        key,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsKeyDeleteExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsKeyDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1AccountsIdLabelsKeyDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/accounts/{id}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1AccountsIdLabelsKeyGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
	key        string
}

func (r ApiApiAccountsMgmtV1AccountsIdLabelsKeyGetRequest) Execute() (Label, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1AccountsIdLabelsKeyGetExecute(r)
}

/*
 * ApiAccountsMgmtV1AccountsIdLabelsKeyGet Get subscription labels by label key
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param key The key of the label
 * @return ApiApiAccountsMgmtV1AccountsIdLabelsKeyGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsKeyGet(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1AccountsIdLabelsKeyGetRequest {
	return ApiApiAccountsMgmtV1AccountsIdLabelsKeyGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		key:        key,
	}
}

/*
 * Execute executes the request
 * @return Label
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsKeyGetExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsKeyGetRequest) (Label, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Label
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1AccountsIdLabelsKeyGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/accounts/{id}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
	key        string
	label      *Label
}

func (r ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest) Label(label Label) ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest {
	r.label = &label
	return r
}

func (r ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest) Execute() (Label, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1AccountsIdLabelsKeyPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1AccountsIdLabelsKeyPatch Create a new label or update an existing label
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param key The key of the label
 * @return ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsKeyPatch(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest {
	return ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		key:        key,
	}
}

/*
 * Execute executes the request
 * @return Label
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsKeyPatchExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsKeyPatchRequest) (Label, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Label
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1AccountsIdLabelsKeyPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/accounts/{id}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.label == nil {
		return localVarReturnValue, nil, reportError("label is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.label
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
	label      *Label
}

func (r ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest) Label(label Label) ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest {
	r.label = &label
	return r
}

func (r ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest) Execute() (Label, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1AccountsIdLabelsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1AccountsIdLabelsPost Create a new label or update an existing label
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest {
	return ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return Label
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdLabelsPostExecute(r ApiApiAccountsMgmtV1AccountsIdLabelsPostRequest) (Label, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Label
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1AccountsIdLabelsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/accounts/{id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.label == nil {
		return localVarReturnValue, nil, reportError("label is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.label
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1AccountsIdPatchRequest struct {
	ctx                 _context.Context
	ApiService          DefaultApi
	id                  string
	accountPatchRequest *AccountPatchRequest
}

func (r ApiApiAccountsMgmtV1AccountsIdPatchRequest) AccountPatchRequest(accountPatchRequest AccountPatchRequest) ApiApiAccountsMgmtV1AccountsIdPatchRequest {
	r.accountPatchRequest = &accountPatchRequest
	return r
}

func (r ApiApiAccountsMgmtV1AccountsIdPatchRequest) Execute() (Account, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1AccountsIdPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1AccountsIdPatch Update an account
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1AccountsIdPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1AccountsIdPatchRequest {
	return ApiApiAccountsMgmtV1AccountsIdPatchRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return Account
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsIdPatchExecute(r ApiApiAccountsMgmtV1AccountsIdPatchRequest) (Account, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1AccountsIdPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/accounts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.accountPatchRequest == nil {
		return localVarReturnValue, nil, reportError("accountPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1AccountsPostRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	account    *Account
	dryRun     *bool
}

func (r ApiApiAccountsMgmtV1AccountsPostRequest) Account(account Account) ApiApiAccountsMgmtV1AccountsPostRequest {
	r.account = &account
	return r
}

func (r ApiApiAccountsMgmtV1AccountsPostRequest) DryRun(dryRun bool) ApiApiAccountsMgmtV1AccountsPostRequest {
	r.dryRun = &dryRun
	return r
}

func (r ApiApiAccountsMgmtV1AccountsPostRequest) Execute() (Account, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1AccountsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1AccountsPost Create a new account
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1AccountsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsPost(ctx _context.Context) ApiApiAccountsMgmtV1AccountsPostRequest {
	return ApiApiAccountsMgmtV1AccountsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return Account
 */
func (a *DefaultApiService) ApiAccountsMgmtV1AccountsPostExecute(r ApiApiAccountsMgmtV1AccountsPostRequest) (Account, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1AccountsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.account == nil {
		return localVarReturnValue, nil, reportError("account is required and must be specified")
	}

	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.account
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest struct {
	ctx                         _context.Context
	ApiService                  DefaultApi
	clusterAuthorizationRequest *ClusterAuthorizationRequest
}

func (r ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest) ClusterAuthorizationRequest(clusterAuthorizationRequest ClusterAuthorizationRequest) ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest {
	r.clusterAuthorizationRequest = &clusterAuthorizationRequest
	return r
}

func (r ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest) Execute() (ClusterAuthorizationResponse, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ClusterAuthorizationsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1ClusterAuthorizationsPost Authorizes new cluster creation against an exsiting RH Subscription.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ClusterAuthorizationsPost(ctx _context.Context) ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest {
	return ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return ClusterAuthorizationResponse
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ClusterAuthorizationsPostExecute(r ApiApiAccountsMgmtV1ClusterAuthorizationsPostRequest) (ClusterAuthorizationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClusterAuthorizationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ClusterAuthorizationsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/cluster_authorizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.clusterAuthorizationRequest == nil {
		return localVarReturnValue, nil, reportError("clusterAuthorizationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clusterAuthorizationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest struct {
	ctx                        _context.Context
	ApiService                 DefaultApi
	clusterRegistrationRequest *ClusterRegistrationRequest
}

func (r ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest) ClusterRegistrationRequest(clusterRegistrationRequest ClusterRegistrationRequest) ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest {
	r.clusterRegistrationRequest = &clusterRegistrationRequest
	return r
}

func (r ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest) Execute() (ClusterRegistrationResponse, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ClusterRegistrationsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1ClusterRegistrationsPost Finds or creates a cluster registration with a registy credential token and cluster ID
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ClusterRegistrationsPost(ctx _context.Context) ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest {
	return ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return ClusterRegistrationResponse
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ClusterRegistrationsPostExecute(r ApiApiAccountsMgmtV1ClusterRegistrationsPostRequest) (ClusterRegistrationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClusterRegistrationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ClusterRegistrationsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/cluster_registrations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.clusterRegistrationRequest == nil {
		return localVarReturnValue, nil, reportError("clusterRegistrationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clusterRegistrationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1CurrentAccountGetRequest struct {
	ctx         _context.Context
	ApiService  DefaultApi
	fetchLabels *bool
}

func (r ApiApiAccountsMgmtV1CurrentAccountGetRequest) FetchLabels(fetchLabels bool) ApiApiAccountsMgmtV1CurrentAccountGetRequest {
	r.fetchLabels = &fetchLabels
	return r
}

func (r ApiApiAccountsMgmtV1CurrentAccountGetRequest) Execute() (Account, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1CurrentAccountGetExecute(r)
}

/*
 * ApiAccountsMgmtV1CurrentAccountGet Get the authenticated account
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1CurrentAccountGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1CurrentAccountGet(ctx _context.Context) ApiApiAccountsMgmtV1CurrentAccountGetRequest {
	return ApiApiAccountsMgmtV1CurrentAccountGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return Account
 */
func (a *DefaultApiService) ApiAccountsMgmtV1CurrentAccountGetExecute(r ApiApiAccountsMgmtV1CurrentAccountGetRequest) (Account, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1CurrentAccountGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/current_account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fetchLabels != nil {
		localVarQueryParams.Add("fetchLabels", parameterToString(*r.fetchLabels, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ErrorsGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	page       *int32
	size       *int32
	search     *string
}

func (r ApiApiAccountsMgmtV1ErrorsGetRequest) Page(page int32) ApiApiAccountsMgmtV1ErrorsGetRequest {
	r.page = &page
	return r
}

func (r ApiApiAccountsMgmtV1ErrorsGetRequest) Size(size int32) ApiApiAccountsMgmtV1ErrorsGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1ErrorsGetRequest) Search(search string) ApiApiAccountsMgmtV1ErrorsGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1ErrorsGetRequest) Execute() (ErrorList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ErrorsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1ErrorsGet Returns a list of errors
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1ErrorsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ErrorsGet(ctx _context.Context) ApiApiAccountsMgmtV1ErrorsGetRequest {
	return ApiApiAccountsMgmtV1ErrorsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return ErrorList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ErrorsGetExecute(r ApiApiAccountsMgmtV1ErrorsGetRequest) (ErrorList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ErrorList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ErrorsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/errors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ErrorsIdGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
}

func (r ApiApiAccountsMgmtV1ErrorsIdGetRequest) Execute() (Error, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ErrorsIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1ErrorsIdGet Get an error by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1ErrorsIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ErrorsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1ErrorsIdGetRequest {
	return ApiApiAccountsMgmtV1ErrorsIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return Error
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ErrorsIdGetExecute(r ApiApiAccountsMgmtV1ErrorsIdGetRequest) (Error, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Error
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ErrorsIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/errors/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest struct {
	ctx                       _context.Context
	ApiService                DefaultApi
	id                        string
	featureToggleQueryRequest *FeatureToggleQueryRequest
}

func (r ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest) FeatureToggleQueryRequest(featureToggleQueryRequest FeatureToggleQueryRequest) ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest {
	r.featureToggleQueryRequest = &featureToggleQueryRequest
	return r
}

func (r ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest) Execute() (FeatureToggle, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1FeatureTogglesIdQueryPostExecute(r)
}

/*
 * ApiAccountsMgmtV1FeatureTogglesIdQueryPost Query a feature toggle by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1FeatureTogglesIdQueryPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest {
	return ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return FeatureToggle
 */
func (a *DefaultApiService) ApiAccountsMgmtV1FeatureTogglesIdQueryPostExecute(r ApiApiAccountsMgmtV1FeatureTogglesIdQueryPostRequest) (FeatureToggle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FeatureToggle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1FeatureTogglesIdQueryPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/feature_toggles/{id}/query"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.featureToggleQueryRequest == nil {
		return localVarReturnValue, nil, reportError("featureToggleQueryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.featureToggleQueryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1LabelsGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	page       *int32
	size       *int32
	search     *string
	orderBy    *string
}

func (r ApiApiAccountsMgmtV1LabelsGetRequest) Page(page int32) ApiApiAccountsMgmtV1LabelsGetRequest {
	r.page = &page
	return r
}

func (r ApiApiAccountsMgmtV1LabelsGetRequest) Size(size int32) ApiApiAccountsMgmtV1LabelsGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1LabelsGetRequest) Search(search string) ApiApiAccountsMgmtV1LabelsGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1LabelsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1LabelsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1LabelsGetRequest) Execute() (LabelList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1LabelsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1LabelsGet Returns a list of labels
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1LabelsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1LabelsGet(ctx _context.Context) ApiApiAccountsMgmtV1LabelsGetRequest {
	return ApiApiAccountsMgmtV1LabelsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return LabelList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1LabelsGetExecute(r ApiApiAccountsMgmtV1LabelsGetRequest) (LabelList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LabelList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1LabelsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/labels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1MetricsGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	search     *string
}

func (r ApiApiAccountsMgmtV1MetricsGetRequest) Search(search string) ApiApiAccountsMgmtV1MetricsGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1MetricsGetRequest) Execute() (MetricsList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1MetricsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1MetricsGet Returns a list of metrics
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1MetricsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1MetricsGet(ctx _context.Context) ApiApiAccountsMgmtV1MetricsGetRequest {
	return ApiApiAccountsMgmtV1MetricsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return MetricsList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1MetricsGetExecute(r ApiApiAccountsMgmtV1MetricsGetRequest) (MetricsList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MetricsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1MetricsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/metrics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1NotifyPostRequest struct {
	ctx                 _context.Context
	ApiService          DefaultApi
	notificationRequest *NotificationRequest
}

func (r ApiApiAccountsMgmtV1NotifyPostRequest) NotificationRequest(notificationRequest NotificationRequest) ApiApiAccountsMgmtV1NotifyPostRequest {
	r.notificationRequest = &notificationRequest
	return r
}

func (r ApiApiAccountsMgmtV1NotifyPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1NotifyPostExecute(r)
}

/*
 * ApiAccountsMgmtV1NotifyPost Notify the owner of cluster/subscription
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1NotifyPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1NotifyPost(ctx _context.Context) ApiApiAccountsMgmtV1NotifyPostRequest {
	return ApiApiAccountsMgmtV1NotifyPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1NotifyPostExecute(r ApiApiAccountsMgmtV1NotifyPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1NotifyPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/notify"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.notificationRequest == nil {
		return nil, reportError("notificationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsGetRequest struct {
	ctx               _context.Context
	ApiService        DefaultApi
	page              *int32
	size              *int32
	search            *string
	orderBy           *string
	fetchLabels       *bool
	fetchCapabilities *bool
	fields            *string
}

func (r ApiApiAccountsMgmtV1OrganizationsGetRequest) Page(page int32) ApiApiAccountsMgmtV1OrganizationsGetRequest {
	r.page = &page
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsGetRequest) Size(size int32) ApiApiAccountsMgmtV1OrganizationsGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsGetRequest) Search(search string) ApiApiAccountsMgmtV1OrganizationsGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1OrganizationsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsGetRequest) FetchLabels(fetchLabels bool) ApiApiAccountsMgmtV1OrganizationsGetRequest {
	r.fetchLabels = &fetchLabels
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsGetRequest) FetchCapabilities(fetchCapabilities bool) ApiApiAccountsMgmtV1OrganizationsGetRequest {
	r.fetchCapabilities = &fetchCapabilities
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsGetRequest) Fields(fields string) ApiApiAccountsMgmtV1OrganizationsGetRequest {
	r.fields = &fields
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsGetRequest) Execute() (OrganizationList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsGet Returns a list of organizations
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1OrganizationsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsGet(ctx _context.Context) ApiApiAccountsMgmtV1OrganizationsGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return OrganizationList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsGetExecute(r ApiApiAccountsMgmtV1OrganizationsGetRequest) (OrganizationList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OrganizationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	if r.fetchLabels != nil {
		localVarQueryParams.Add("fetchLabels", parameterToString(*r.fetchLabels, ""))
	}
	if r.fetchCapabilities != nil {
		localVarQueryParams.Add("fetchCapabilities", parameterToString(*r.fetchCapabilities, ""))
	}
	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsIdGetRequest struct {
	ctx               _context.Context
	ApiService        DefaultApi
	id                string
	fetchLabels       *bool
	fetchCapabilities *bool
}

func (r ApiApiAccountsMgmtV1OrganizationsIdGetRequest) FetchLabels(fetchLabels bool) ApiApiAccountsMgmtV1OrganizationsIdGetRequest {
	r.fetchLabels = &fetchLabels
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsIdGetRequest) FetchCapabilities(fetchCapabilities bool) ApiApiAccountsMgmtV1OrganizationsIdGetRequest {
	r.fetchCapabilities = &fetchCapabilities
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsIdGetRequest) Execute() (Organization, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsIdGet Get an organization by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1OrganizationsIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return Organization
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdGetExecute(r ApiApiAccountsMgmtV1OrganizationsIdGetRequest) (Organization, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fetchLabels != nil {
		localVarQueryParams.Add("fetchLabels", parameterToString(*r.fetchLabels, ""))
	}
	if r.fetchCapabilities != nil {
		localVarQueryParams.Add("fetchCapabilities", parameterToString(*r.fetchCapabilities, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
	page       *int32
	size       *int32
	search     *string
	orderBy    *string
}

func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest) Page(page int32) ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest {
	r.page = &page
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest) Size(size int32) ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest) Search(search string) ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest) Execute() (LabelList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsIdLabelsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsIdLabelsGet Returns a list of labels
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return LabelList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsGetExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsGetRequest) (LabelList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LabelList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsIdLabelsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
	key        string
}

func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsIdLabelsKeyDelete Delete a label
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param key The key of the label
 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsKeyDelete(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteRequest {
	return ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		key:        key,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsIdLabelsKeyDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{id}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
	key        string
}

func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyGetRequest) Execute() (Label, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsIdLabelsKeyGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsIdLabelsKeyGet Get subscription labels by label key
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param key The key of the label
 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsKeyGet(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		key:        key,
	}
}

/*
 * Execute executes the request
 * @return Label
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsKeyGetExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyGetRequest) (Label, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Label
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsIdLabelsKeyGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{id}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
	key        string
	label      *Label
}

func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest) Label(label Label) ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest {
	r.label = &label
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest) Execute() (Label, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsIdLabelsKeyPatch Create a new label or update an existing label
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param key The key of the label
 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsKeyPatch(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest {
	return ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		key:        key,
	}
}

/*
 * Execute executes the request
 * @return Label
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsKeyPatchRequest) (Label, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Label
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsIdLabelsKeyPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{id}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.label == nil {
		return localVarReturnValue, nil, reportError("label is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.label
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
	label      *Label
}

func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest) Label(label Label) ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest {
	r.label = &label
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest) Execute() (Label, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsIdLabelsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsIdLabelsPost Create a new label or update an existing label
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest {
	return ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return Label
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdLabelsPostExecute(r ApiApiAccountsMgmtV1OrganizationsIdLabelsPostRequest) (Label, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Label
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsIdLabelsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.label == nil {
		return localVarReturnValue, nil, reportError("label is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.label
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsIdPatchRequest struct {
	ctx                      _context.Context
	ApiService               DefaultApi
	id                       string
	organizationPatchRequest *OrganizationPatchRequest
}

func (r ApiApiAccountsMgmtV1OrganizationsIdPatchRequest) OrganizationPatchRequest(organizationPatchRequest OrganizationPatchRequest) ApiApiAccountsMgmtV1OrganizationsIdPatchRequest {
	r.organizationPatchRequest = &organizationPatchRequest
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsIdPatchRequest) Execute() (Organization, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsIdPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsIdPatch Update an organization
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1OrganizationsIdPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdPatchRequest {
	return ApiApiAccountsMgmtV1OrganizationsIdPatchRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return Organization
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdPatchExecute(r ApiApiAccountsMgmtV1OrganizationsIdPatchRequest) (Organization, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsIdPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.organizationPatchRequest == nil {
		return localVarReturnValue, nil, reportError("organizationPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.organizationPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
}

func (r ApiApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetRequest) Execute() (Summary, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsIdSummaryDashboardGet Returns a summary of organizations clusters based on metrics
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdSummaryDashboardGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return Summary
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetExecute(r ApiApiAccountsMgmtV1OrganizationsIdSummaryDashboardGetRequest) (Summary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Summary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsIdSummaryDashboardGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{id}/summary_dashboard"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGetRequest struct {
	ctx                   _context.Context
	ApiService            DefaultApi
	orgId                 string
	search                *string
	fetchRelatedResources *bool
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGetRequest) Search(search string) ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGetRequest) FetchRelatedResources(fetchRelatedResources bool) ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGetRequest {
	r.fetchRelatedResources = &fetchRelatedResources
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGetRequest) Execute() (QuotaCostList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGet Returns a summary of quota cost
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGet(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGetRequest{
		ApiService: a,
		ctx:        ctx,
		orgId:      orgId,
	}
}

/*
 * Execute executes the request
 * @return QuotaCostList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGetRequest) (QuotaCostList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  QuotaCostList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdQuotaCostGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/quota_cost"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.fetchRelatedResources != nil {
		localVarQueryParams.Add("fetchRelatedResources", parameterToString(*r.fetchRelatedResources, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	orgId      string
	search     *string
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGetRequest) Search(search string) ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGetRequest) Execute() (QuotaSummaryList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGet Returns a summary of resource quota
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGet(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGetRequest{
		ApiService: a,
		ctx:        ctx,
		orgId:      orgId,
	}
}

/*
 * Execute executes the request
 * @return QuotaSummaryList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGetRequest) (QuotaSummaryList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  QuotaSummaryList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdQuotaSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/quota_summary"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	orgId      string
	page       *int32
	size       *int32
	search     *string
	orderBy    *string
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest) Page(page int32) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest {
	r.page = &page
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest) Size(size int32) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest) Search(search string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest) Execute() (ResourceQuotaList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGet Returns a list of resource quota objects
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGet(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest{
		ApiService: a,
		ctx:        ctx,
		orgId:      orgId,
	}
}

/*
 * Execute executes the request
 * @return ResourceQuotaList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGetRequest) (ResourceQuotaList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceQuotaList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/resource_quota"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest struct {
	ctx                  _context.Context
	ApiService           DefaultApi
	orgId                string
	resourceQuotaRequest *ResourceQuotaRequest
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest) ResourceQuotaRequest(resourceQuotaRequest ResourceQuotaRequest) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest {
	r.resourceQuotaRequest = &resourceQuotaRequest
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest) Execute() (ResourceQuota, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPost Create a new resource quota
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPost(ctx _context.Context, orgId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest{
		ApiService: a,
		ctx:        ctx,
		orgId:      orgId,
	}
}

/*
 * Execute executes the request
 * @return ResourceQuota
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPostRequest) (ResourceQuota, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceQuota
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/resource_quota"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.resourceQuotaRequest == nil {
		return localVarReturnValue, nil, reportError("resourceQuotaRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resourceQuotaRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	orgId      string
	quotaId    string
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDelete Delete a resource quota
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @param quotaId The id of quota
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDelete(ctx _context.Context, orgId string, quotaId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		orgId:      orgId,
		quotaId:    quotaId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/resource_quota/{quotaId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"quotaId"+"}", _neturl.PathEscape(parameterToString(r.quotaId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	orgId      string
	quotaId    string
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetRequest) Execute() (ResourceQuota, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGet Get a resource quota by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @param quotaId The id of quota
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGet(ctx _context.Context, orgId string, quotaId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		orgId:      orgId,
		quotaId:    quotaId,
	}
}

/*
 * Execute executes the request
 * @return ResourceQuota
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGetRequest) (ResourceQuota, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceQuota
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/resource_quota/{quotaId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"quotaId"+"}", _neturl.PathEscape(parameterToString(r.quotaId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest struct {
	ctx                  _context.Context
	ApiService           DefaultApi
	orgId                string
	quotaId              string
	resourceQuotaRequest *ResourceQuotaRequest
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest) ResourceQuotaRequest(resourceQuotaRequest ResourceQuotaRequest) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest {
	r.resourceQuotaRequest = &resourceQuotaRequest
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest) Execute() (ResourceQuota, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatch Update a resource quota
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param orgId The id of organization
 * @param quotaId The id of quota
 * @return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatch(ctx _context.Context, orgId string, quotaId string) ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest {
	return ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest{
		ApiService: a,
		ctx:        ctx,
		orgId:      orgId,
		quotaId:    quotaId,
	}
}

/*
 * Execute executes the request
 * @return ResourceQuota
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchExecute(r ApiApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatchRequest) (ResourceQuota, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceQuota
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsOrgIdResourceQuotaQuotaIdPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations/{orgId}/resource_quota/{quotaId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", _neturl.PathEscape(parameterToString(r.orgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"quotaId"+"}", _neturl.PathEscape(parameterToString(r.quotaId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.resourceQuotaRequest == nil {
		return localVarReturnValue, nil, reportError("resourceQuotaRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resourceQuotaRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1OrganizationsPostRequest struct {
	ctx          _context.Context
	ApiService   DefaultApi
	organization *Organization
}

func (r ApiApiAccountsMgmtV1OrganizationsPostRequest) Organization(organization Organization) ApiApiAccountsMgmtV1OrganizationsPostRequest {
	r.organization = &organization
	return r
}

func (r ApiApiAccountsMgmtV1OrganizationsPostRequest) Execute() (Organization, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1OrganizationsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1OrganizationsPost Create a new organization
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1OrganizationsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsPost(ctx _context.Context) ApiApiAccountsMgmtV1OrganizationsPostRequest {
	return ApiApiAccountsMgmtV1OrganizationsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return Organization
 */
func (a *DefaultApiService) ApiAccountsMgmtV1OrganizationsPostExecute(r ApiApiAccountsMgmtV1OrganizationsPostRequest) (Organization, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1OrganizationsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/organizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.organization == nil {
		return localVarReturnValue, nil, reportError("organization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.organization
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1PlansGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	page       *int32
	size       *int32
	search     *string
}

func (r ApiApiAccountsMgmtV1PlansGetRequest) Page(page int32) ApiApiAccountsMgmtV1PlansGetRequest {
	r.page = &page
	return r
}

func (r ApiApiAccountsMgmtV1PlansGetRequest) Size(size int32) ApiApiAccountsMgmtV1PlansGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1PlansGetRequest) Search(search string) ApiApiAccountsMgmtV1PlansGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1PlansGetRequest) Execute() (PlanList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1PlansGetExecute(r)
}

/*
 * ApiAccountsMgmtV1PlansGet Get all plans
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1PlansGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1PlansGet(ctx _context.Context) ApiApiAccountsMgmtV1PlansGetRequest {
	return ApiApiAccountsMgmtV1PlansGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return PlanList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1PlansGetExecute(r ApiApiAccountsMgmtV1PlansGetRequest) (PlanList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PlanList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1PlansGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/plans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1PlansIdGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
}

func (r ApiApiAccountsMgmtV1PlansIdGetRequest) Execute() (Plan, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1PlansIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1PlansIdGet Get a plan by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1PlansIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1PlansIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1PlansIdGetRequest {
	return ApiApiAccountsMgmtV1PlansIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return Plan
 */
func (a *DefaultApiService) ApiAccountsMgmtV1PlansIdGetExecute(r ApiApiAccountsMgmtV1PlansIdGetRequest) (Plan, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Plan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1PlansIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/plans/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteRequest struct {
	ctx                _context.Context
	ApiService         DefaultApi
	externalResourceId string
}

func (r ApiApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1PullSecretsExternalResourceIdDelete Delete a pull secret
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param externalResourceId The external resource id of record
 * @return ApiApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1PullSecretsExternalResourceIdDelete(ctx _context.Context, externalResourceId string) ApiApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteRequest {
	return ApiApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteRequest{
		ApiService:         a,
		ctx:                ctx,
		externalResourceId: externalResourceId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteExecute(r ApiApiAccountsMgmtV1PullSecretsExternalResourceIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1PullSecretsExternalResourceIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/pull_secrets/{externalResourceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"externalResourceId"+"}", _neturl.PathEscape(parameterToString(r.externalResourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1PullSecretsPostRequest struct {
	ctx               _context.Context
	ApiService        DefaultApi
	pullSecretRequest *PullSecretRequest
}

func (r ApiApiAccountsMgmtV1PullSecretsPostRequest) PullSecretRequest(pullSecretRequest PullSecretRequest) ApiApiAccountsMgmtV1PullSecretsPostRequest {
	r.pullSecretRequest = &pullSecretRequest
	return r
}

func (r ApiApiAccountsMgmtV1PullSecretsPostRequest) Execute() (AccessTokenCfg, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1PullSecretsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1PullSecretsPost Return access token generated from registries in docker format
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1PullSecretsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1PullSecretsPost(ctx _context.Context) ApiApiAccountsMgmtV1PullSecretsPostRequest {
	return ApiApiAccountsMgmtV1PullSecretsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return AccessTokenCfg
 */
func (a *DefaultApiService) ApiAccountsMgmtV1PullSecretsPostExecute(r ApiApiAccountsMgmtV1PullSecretsPostRequest) (AccessTokenCfg, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccessTokenCfg
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1PullSecretsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/pull_secrets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.pullSecretRequest == nil {
		return localVarReturnValue, nil, reportError("pullSecretRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pullSecretRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RegistriesGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	page       *int32
	size       *int32
	search     *string
	orderBy    *string
}

func (r ApiApiAccountsMgmtV1RegistriesGetRequest) Page(page int32) ApiApiAccountsMgmtV1RegistriesGetRequest {
	r.page = &page
	return r
}

func (r ApiApiAccountsMgmtV1RegistriesGetRequest) Size(size int32) ApiApiAccountsMgmtV1RegistriesGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1RegistriesGetRequest) Search(search string) ApiApiAccountsMgmtV1RegistriesGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1RegistriesGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1RegistriesGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1RegistriesGetRequest) Execute() (RegistryList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RegistriesGetExecute(r)
}

/*
 * ApiAccountsMgmtV1RegistriesGet Returns a list of registries
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1RegistriesGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistriesGet(ctx _context.Context) ApiApiAccountsMgmtV1RegistriesGetRequest {
	return ApiApiAccountsMgmtV1RegistriesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return RegistryList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistriesGetExecute(r ApiApiAccountsMgmtV1RegistriesGetRequest) (RegistryList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RegistryList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RegistriesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/registries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RegistriesIdGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
}

func (r ApiApiAccountsMgmtV1RegistriesIdGetRequest) Execute() (Registry, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RegistriesIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1RegistriesIdGet Get an registry by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1RegistriesIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistriesIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1RegistriesIdGetRequest {
	return ApiApiAccountsMgmtV1RegistriesIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return Registry
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistriesIdGetExecute(r ApiApiAccountsMgmtV1RegistriesIdGetRequest) (Registry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Registry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RegistriesIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/registries/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RegistryCredentialsGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	page       *int32
	size       *int32
	search     *string
	orderBy    *string
}

func (r ApiApiAccountsMgmtV1RegistryCredentialsGetRequest) Page(page int32) ApiApiAccountsMgmtV1RegistryCredentialsGetRequest {
	r.page = &page
	return r
}

func (r ApiApiAccountsMgmtV1RegistryCredentialsGetRequest) Size(size int32) ApiApiAccountsMgmtV1RegistryCredentialsGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1RegistryCredentialsGetRequest) Search(search string) ApiApiAccountsMgmtV1RegistryCredentialsGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1RegistryCredentialsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1RegistryCredentialsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1RegistryCredentialsGetRequest) Execute() (RegistryCredentialList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RegistryCredentialsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1RegistryCredentialsGet Method for ApiAccountsMgmtV1RegistryCredentialsGet
 * List Registry Credentials
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1RegistryCredentialsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsGet(ctx _context.Context) ApiApiAccountsMgmtV1RegistryCredentialsGetRequest {
	return ApiApiAccountsMgmtV1RegistryCredentialsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return RegistryCredentialList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsGetExecute(r ApiApiAccountsMgmtV1RegistryCredentialsGetRequest) (RegistryCredentialList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RegistryCredentialList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RegistryCredentialsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/registry_credentials"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RegistryCredentialsIdDeleteRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
}

func (r ApiApiAccountsMgmtV1RegistryCredentialsIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RegistryCredentialsIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1RegistryCredentialsIdDelete Delete a registry credential by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1RegistryCredentialsIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1RegistryCredentialsIdDeleteRequest {
	return ApiApiAccountsMgmtV1RegistryCredentialsIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsIdDeleteExecute(r ApiApiAccountsMgmtV1RegistryCredentialsIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RegistryCredentialsIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/registry_credentials/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RegistryCredentialsIdGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
}

func (r ApiApiAccountsMgmtV1RegistryCredentialsIdGetRequest) Execute() (RegistryCredential, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RegistryCredentialsIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1RegistryCredentialsIdGet Get a registry credentials by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1RegistryCredentialsIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1RegistryCredentialsIdGetRequest {
	return ApiApiAccountsMgmtV1RegistryCredentialsIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return RegistryCredential
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsIdGetExecute(r ApiApiAccountsMgmtV1RegistryCredentialsIdGetRequest) (RegistryCredential, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RegistryCredential
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RegistryCredentialsIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/registry_credentials/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest struct {
	ctx                            _context.Context
	ApiService                     DefaultApi
	id                             string
	registryCredentialPatchRequest *RegistryCredentialPatchRequest
}

func (r ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest) RegistryCredentialPatchRequest(registryCredentialPatchRequest RegistryCredentialPatchRequest) ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest {
	r.registryCredentialPatchRequest = &registryCredentialPatchRequest
	return r
}

func (r ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest) Execute() (RegistryCredential, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RegistryCredentialsIdPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1RegistryCredentialsIdPatch Update a registry credential
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest {
	return ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return RegistryCredential
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsIdPatchExecute(r ApiApiAccountsMgmtV1RegistryCredentialsIdPatchRequest) (RegistryCredential, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RegistryCredential
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RegistryCredentialsIdPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/registry_credentials/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.registryCredentialPatchRequest == nil {
		return localVarReturnValue, nil, reportError("registryCredentialPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.registryCredentialPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RegistryCredentialsPostRequest struct {
	ctx                _context.Context
	ApiService         DefaultApi
	registryCredential *RegistryCredential
}

func (r ApiApiAccountsMgmtV1RegistryCredentialsPostRequest) RegistryCredential(registryCredential RegistryCredential) ApiApiAccountsMgmtV1RegistryCredentialsPostRequest {
	r.registryCredential = &registryCredential
	return r
}

func (r ApiApiAccountsMgmtV1RegistryCredentialsPostRequest) Execute() (RegistryCredential, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RegistryCredentialsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1RegistryCredentialsPost Request the creation of a registry credential
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1RegistryCredentialsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsPost(ctx _context.Context) ApiApiAccountsMgmtV1RegistryCredentialsPostRequest {
	return ApiApiAccountsMgmtV1RegistryCredentialsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return RegistryCredential
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RegistryCredentialsPostExecute(r ApiApiAccountsMgmtV1RegistryCredentialsPostRequest) (RegistryCredential, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RegistryCredential
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RegistryCredentialsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/registry_credentials"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.registryCredential == nil {
		return localVarReturnValue, nil, reportError("registryCredential is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.registryCredential
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ReservedResourcesGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	page       *int32
	size       *int32
	search     *string
	orderBy    *string
}

func (r ApiApiAccountsMgmtV1ReservedResourcesGetRequest) Page(page int32) ApiApiAccountsMgmtV1ReservedResourcesGetRequest {
	r.page = &page
	return r
}

func (r ApiApiAccountsMgmtV1ReservedResourcesGetRequest) Size(size int32) ApiApiAccountsMgmtV1ReservedResourcesGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1ReservedResourcesGetRequest) Search(search string) ApiApiAccountsMgmtV1ReservedResourcesGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1ReservedResourcesGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1ReservedResourcesGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1ReservedResourcesGetRequest) Execute() (ReservedResourceList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ReservedResourcesGetExecute(r)
}

/*
 * ApiAccountsMgmtV1ReservedResourcesGet Returns a list of reserved resources
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1ReservedResourcesGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ReservedResourcesGet(ctx _context.Context) ApiApiAccountsMgmtV1ReservedResourcesGetRequest {
	return ApiApiAccountsMgmtV1ReservedResourcesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return ReservedResourceList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ReservedResourcesGetExecute(r ApiApiAccountsMgmtV1ReservedResourcesGetRequest) (ReservedResourceList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReservedResourceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ReservedResourcesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/reserved_resources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1ResourceQuotaGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	page       *int32
	size       *int32
	search     *string
	orderBy    *string
}

func (r ApiApiAccountsMgmtV1ResourceQuotaGetRequest) Page(page int32) ApiApiAccountsMgmtV1ResourceQuotaGetRequest {
	r.page = &page
	return r
}

func (r ApiApiAccountsMgmtV1ResourceQuotaGetRequest) Size(size int32) ApiApiAccountsMgmtV1ResourceQuotaGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1ResourceQuotaGetRequest) Search(search string) ApiApiAccountsMgmtV1ResourceQuotaGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1ResourceQuotaGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1ResourceQuotaGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1ResourceQuotaGetRequest) Execute() (ResourceQuotaList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1ResourceQuotaGetExecute(r)
}

/*
 * ApiAccountsMgmtV1ResourceQuotaGet Returns a list of resource quota objects
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1ResourceQuotaGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ResourceQuotaGet(ctx _context.Context) ApiApiAccountsMgmtV1ResourceQuotaGetRequest {
	return ApiApiAccountsMgmtV1ResourceQuotaGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return ResourceQuotaList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1ResourceQuotaGetExecute(r ApiApiAccountsMgmtV1ResourceQuotaGetRequest) (ResourceQuotaList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceQuotaList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1ResourceQuotaGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/resource_quota"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RoleBindingsGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	page       *int32
	size       *int32
	search     *string
	orderBy    *string
}

func (r ApiApiAccountsMgmtV1RoleBindingsGetRequest) Page(page int32) ApiApiAccountsMgmtV1RoleBindingsGetRequest {
	r.page = &page
	return r
}

func (r ApiApiAccountsMgmtV1RoleBindingsGetRequest) Size(size int32) ApiApiAccountsMgmtV1RoleBindingsGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1RoleBindingsGetRequest) Search(search string) ApiApiAccountsMgmtV1RoleBindingsGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1RoleBindingsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1RoleBindingsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1RoleBindingsGetRequest) Execute() (RoleBindingList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RoleBindingsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1RoleBindingsGet Returns a list of role bindings
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1RoleBindingsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsGet(ctx _context.Context) ApiApiAccountsMgmtV1RoleBindingsGetRequest {
	return ApiApiAccountsMgmtV1RoleBindingsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return RoleBindingList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsGetExecute(r ApiApiAccountsMgmtV1RoleBindingsGetRequest) (RoleBindingList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RoleBindingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RoleBindingsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/role_bindings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RoleBindingsIdDeleteRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
}

func (r ApiApiAccountsMgmtV1RoleBindingsIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RoleBindingsIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1RoleBindingsIdDelete Delete a role binding
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1RoleBindingsIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1RoleBindingsIdDeleteRequest {
	return ApiApiAccountsMgmtV1RoleBindingsIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsIdDeleteExecute(r ApiApiAccountsMgmtV1RoleBindingsIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RoleBindingsIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/role_bindings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RoleBindingsIdGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
}

func (r ApiApiAccountsMgmtV1RoleBindingsIdGetRequest) Execute() (RoleBinding, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RoleBindingsIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1RoleBindingsIdGet Get a role binding
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1RoleBindingsIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1RoleBindingsIdGetRequest {
	return ApiApiAccountsMgmtV1RoleBindingsIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return RoleBinding
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsIdGetExecute(r ApiApiAccountsMgmtV1RoleBindingsIdGetRequest) (RoleBinding, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RoleBindingsIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/role_bindings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest struct {
	ctx                _context.Context
	ApiService         DefaultApi
	id                 string
	roleBindingRequest *RoleBindingRequest
}

func (r ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest) RoleBindingRequest(roleBindingRequest RoleBindingRequest) ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest {
	r.roleBindingRequest = &roleBindingRequest
	return r
}

func (r ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest) Execute() (RoleBinding, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RoleBindingsIdPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1RoleBindingsIdPatch Update a role binding
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest {
	return ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return RoleBinding
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsIdPatchExecute(r ApiApiAccountsMgmtV1RoleBindingsIdPatchRequest) (RoleBinding, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RoleBindingsIdPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/role_bindings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.roleBindingRequest == nil {
		return localVarReturnValue, nil, reportError("roleBindingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleBindingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RoleBindingsPostRequest struct {
	ctx                      _context.Context
	ApiService               DefaultApi
	roleBindingCreateRequest *RoleBindingCreateRequest
}

func (r ApiApiAccountsMgmtV1RoleBindingsPostRequest) RoleBindingCreateRequest(roleBindingCreateRequest RoleBindingCreateRequest) ApiApiAccountsMgmtV1RoleBindingsPostRequest {
	r.roleBindingCreateRequest = &roleBindingCreateRequest
	return r
}

func (r ApiApiAccountsMgmtV1RoleBindingsPostRequest) Execute() (RoleBinding, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RoleBindingsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1RoleBindingsPost Create a new role binding
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1RoleBindingsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsPost(ctx _context.Context) ApiApiAccountsMgmtV1RoleBindingsPostRequest {
	return ApiApiAccountsMgmtV1RoleBindingsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return RoleBinding
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RoleBindingsPostExecute(r ApiApiAccountsMgmtV1RoleBindingsPostRequest) (RoleBinding, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RoleBindingsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/role_bindings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.roleBindingCreateRequest == nil {
		return localVarReturnValue, nil, reportError("roleBindingCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleBindingCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RolesGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	page       *int32
	size       *int32
	search     *string
}

func (r ApiApiAccountsMgmtV1RolesGetRequest) Page(page int32) ApiApiAccountsMgmtV1RolesGetRequest {
	r.page = &page
	return r
}

func (r ApiApiAccountsMgmtV1RolesGetRequest) Size(size int32) ApiApiAccountsMgmtV1RolesGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1RolesGetRequest) Search(search string) ApiApiAccountsMgmtV1RolesGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1RolesGetRequest) Execute() (RoleList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RolesGetExecute(r)
}

/*
 * ApiAccountsMgmtV1RolesGet Returns a list of roles
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1RolesGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RolesGet(ctx _context.Context) ApiApiAccountsMgmtV1RolesGetRequest {
	return ApiApiAccountsMgmtV1RolesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return RoleList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RolesGetExecute(r ApiApiAccountsMgmtV1RolesGetRequest) (RoleList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RoleList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RolesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1RolesIdGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
}

func (r ApiApiAccountsMgmtV1RolesIdGetRequest) Execute() (Role, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1RolesIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1RolesIdGet Get a role by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1RolesIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RolesIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1RolesIdGetRequest {
	return ApiApiAccountsMgmtV1RolesIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return Role
 */
func (a *DefaultApiService) ApiAccountsMgmtV1RolesIdGetExecute(r ApiApiAccountsMgmtV1RolesIdGetRequest) (Role, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1RolesIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/roles/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SkuRulesGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	search     *string
}

func (r ApiApiAccountsMgmtV1SkuRulesGetRequest) Search(search string) ApiApiAccountsMgmtV1SkuRulesGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1SkuRulesGetRequest) Execute() (SkuRulesList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SkuRulesGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SkuRulesGet Returns a list of UHC product SKU Rules
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1SkuRulesGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkuRulesGet(ctx _context.Context) ApiApiAccountsMgmtV1SkuRulesGetRequest {
	return ApiApiAccountsMgmtV1SkuRulesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SkuRulesList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkuRulesGetExecute(r ApiApiAccountsMgmtV1SkuRulesGetRequest) (SkuRulesList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SkuRulesList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SkuRulesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/sku_rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SkuRulesIdGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
}

func (r ApiApiAccountsMgmtV1SkuRulesIdGetRequest) Execute() (SkuRules, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SkuRulesIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SkuRulesIdGet Get a sku rules by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SkuRulesIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkuRulesIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SkuRulesIdGetRequest {
	return ApiApiAccountsMgmtV1SkuRulesIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return SkuRules
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkuRulesIdGetExecute(r ApiApiAccountsMgmtV1SkuRulesIdGetRequest) (SkuRules, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SkuRules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SkuRulesIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/sku_rules/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SkusGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	search     *string
}

func (r ApiApiAccountsMgmtV1SkusGetRequest) Search(search string) ApiApiAccountsMgmtV1SkusGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1SkusGetRequest) Execute() (SkuList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SkusGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SkusGet Returns a list of UHC product SKUs
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1SkusGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkusGet(ctx _context.Context) ApiApiAccountsMgmtV1SkusGetRequest {
	return ApiApiAccountsMgmtV1SkusGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SkuList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkusGetExecute(r ApiApiAccountsMgmtV1SkusGetRequest) (SkuList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SkuList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SkusGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/skus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SkusIdGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
}

func (r ApiApiAccountsMgmtV1SkusIdGetRequest) Execute() (SKU, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SkusIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SkusIdGet Get a sku by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SkusIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkusIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SkusIdGetRequest {
	return ApiApiAccountsMgmtV1SkusIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return SKU
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SkusIdGetExecute(r ApiApiAccountsMgmtV1SkusIdGetRequest) (SKU, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SKU
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SkusIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/skus/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsGetRequest struct {
	ctx               _context.Context
	ApiService        DefaultApi
	page              *int32
	size              *int32
	search            *string
	fetchAccounts     *bool
	fetchLabels       *bool
	fetchCapabilities *bool
	fields            *string
	orderBy           *string
	labels            *string
}

func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) Page(page int32) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	r.page = &page
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) Size(size int32) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) Search(search string) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) FetchAccounts(fetchAccounts bool) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	r.fetchAccounts = &fetchAccounts
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) FetchLabels(fetchLabels bool) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	r.fetchLabels = &fetchLabels
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) FetchCapabilities(fetchCapabilities bool) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	r.fetchCapabilities = &fetchCapabilities
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) Fields(fields string) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	r.fields = &fields
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) Labels(labels string) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	r.labels = &labels
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsGetRequest) Execute() (SubscriptionList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsGet Returns a list of subscriptions
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1SubscriptionsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsGet(ctx _context.Context) ApiApiAccountsMgmtV1SubscriptionsGetRequest {
	return ApiApiAccountsMgmtV1SubscriptionsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SubscriptionList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsGetExecute(r ApiApiAccountsMgmtV1SubscriptionsGetRequest) (SubscriptionList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SubscriptionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.fetchAccounts != nil {
		localVarQueryParams.Add("fetchAccounts", parameterToString(*r.fetchAccounts, ""))
	}
	if r.fetchLabels != nil {
		localVarQueryParams.Add("fetchLabels", parameterToString(*r.fetchLabels, ""))
	}
	if r.fetchCapabilities != nil {
		localVarQueryParams.Add("fetchCapabilities", parameterToString(*r.fetchCapabilities, ""))
	}
	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	if r.labels != nil {
		localVarQueryParams.Add("labels", parameterToString(*r.labels, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdDeleteRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdDelete Deletes a subscription by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SubscriptionsIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdDelete(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdDeleteRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdDeleteExecute(r ApiApiAccountsMgmtV1SubscriptionsIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdGetRequest struct {
	ctx               _context.Context
	ApiService        DefaultApi
	id                string
	fetchAccounts     *bool
	fetchLabels       *bool
	fetchCapabilities *bool
	fetchCpuAndSocket *bool
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdGetRequest) FetchAccounts(fetchAccounts bool) ApiApiAccountsMgmtV1SubscriptionsIdGetRequest {
	r.fetchAccounts = &fetchAccounts
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdGetRequest) FetchLabels(fetchLabels bool) ApiApiAccountsMgmtV1SubscriptionsIdGetRequest {
	r.fetchLabels = &fetchLabels
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdGetRequest) FetchCapabilities(fetchCapabilities bool) ApiApiAccountsMgmtV1SubscriptionsIdGetRequest {
	r.fetchCapabilities = &fetchCapabilities
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdGetRequest) FetchCpuAndSocket(fetchCpuAndSocket bool) ApiApiAccountsMgmtV1SubscriptionsIdGetRequest {
	r.fetchCpuAndSocket = &fetchCpuAndSocket
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdGetRequest) Execute() (Subscription, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdGet Get a subscription by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SubscriptionsIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdGetRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return Subscription
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdGetRequest) (Subscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fetchAccounts != nil {
		localVarQueryParams.Add("fetchAccounts", parameterToString(*r.fetchAccounts, ""))
	}
	if r.fetchLabels != nil {
		localVarQueryParams.Add("fetchLabels", parameterToString(*r.fetchLabels, ""))
	}
	if r.fetchCapabilities != nil {
		localVarQueryParams.Add("fetchCapabilities", parameterToString(*r.fetchCapabilities, ""))
	}
	if r.fetchCpuAndSocket != nil {
		localVarQueryParams.Add("fetchCpuAndSocket", parameterToString(*r.fetchCpuAndSocket, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
	page       *int32
	size       *int32
	search     *string
	orderBy    *string
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest) Page(page int32) ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest {
	r.page = &page
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest) Size(size int32) ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest) Search(search string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest) Execute() (LabelList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdLabelsGet Returns a list of labels
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return LabelList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsGetRequest) (LabelList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LabelList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
	key        string
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdLabelsKeyDelete Delete a label
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param key The key of the label
 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsKeyDelete(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		key:        key,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsKeyDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
	key        string
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetRequest) Execute() (Label, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdLabelsKeyGet Get subscription labels by label key
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param key The key of the label
 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsKeyGet(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		key:        key,
	}
}

/*
 * Execute executes the request
 * @return Label
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyGetRequest) (Label, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Label
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsKeyGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
	key        string
	label      *Label
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest) Label(label Label) ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest {
	r.label = &label
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest) Execute() (Label, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatch Create a new label or update an existing label
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @param key The key of the label
 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatch(ctx _context.Context, id string, key string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		key:        key,
	}
}

/*
 * Execute executes the request
 * @return Label
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatchRequest) (Label, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Label
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsKeyPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", _neturl.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.label == nil {
		return localVarReturnValue, nil, reportError("label is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.label
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
	label      *Label
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest) Label(label Label) ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest {
	r.label = &label
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest) Execute() (Label, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdLabelsPost Create a new label or update an existing label
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return Label
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdLabelsPostExecute(r ApiApiAccountsMgmtV1SubscriptionsIdLabelsPostRequest) (Label, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Label
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdLabelsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.label == nil {
		return localVarReturnValue, nil, reportError("label is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.label
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest struct {
	ctx                 _context.Context
	ApiService          DefaultApi
	id                  string
	notificationRequest *NotificationRequest
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest) NotificationRequest(notificationRequest NotificationRequest) ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest {
	r.notificationRequest = &notificationRequest
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdNotifyPostExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdNotifyPost Notify the owner of a subscription
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdNotifyPost(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdNotifyPostExecute(r ApiApiAccountsMgmtV1SubscriptionsIdNotifyPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdNotifyPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}/notify"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.notificationRequest == nil {
		return nil, reportError("notificationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest struct {
	ctx                      _context.Context
	ApiService               DefaultApi
	id                       string
	subscriptionPatchRequest *SubscriptionPatchRequest
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest) SubscriptionPatchRequest(subscriptionPatchRequest SubscriptionPatchRequest) ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest {
	r.subscriptionPatchRequest = &subscriptionPatchRequest
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest) Execute() (Subscription, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdPatchExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdPatch Update a subscription
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdPatch(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return Subscription
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdPatchExecute(r ApiApiAccountsMgmtV1SubscriptionsIdPatchRequest) (Subscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.subscriptionPatchRequest == nil {
		return localVarReturnValue, nil, reportError("subscriptionPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscriptionPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
	page       *int32
	size       *int32
	search     *string
	orderBy    *string
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest) Page(page int32) ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest {
	r.page = &page
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest) Size(size int32) ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest) Search(search string) ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest) Execute() (ReservedResourceList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdReservedResourcesGet Returns a list of reserved resources
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdReservedResourcesGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return ReservedResourceList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdReservedResourcesGetRequest) (ReservedResourceList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReservedResourceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdReservedResourcesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}/reserved_resources"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	id         string
	page       *int32
	size       *int32
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest) Page(page int32) ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest {
	r.page = &page
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest) Size(size int32) ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsIdSupportCasesGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsIdSupportCasesGet Returns a list of open support creates opened against the external cluster id of this subscrption
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of record
 * @return ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdSupportCasesGet(ctx _context.Context, id string) ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest {
	return ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsIdSupportCasesGetExecute(r ApiApiAccountsMgmtV1SubscriptionsIdSupportCasesGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsIdSupportCasesGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{id}/support_cases"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsPostRequest struct {
	ctx                       _context.Context
	ApiService                DefaultApi
	subscriptionCreateRequest *SubscriptionCreateRequest
}

func (r ApiApiAccountsMgmtV1SubscriptionsPostRequest) SubscriptionCreateRequest(subscriptionCreateRequest SubscriptionCreateRequest) ApiApiAccountsMgmtV1SubscriptionsPostRequest {
	r.subscriptionCreateRequest = &subscriptionCreateRequest
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsPostRequest) Execute() (Subscription, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsPost Create a new subscription
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1SubscriptionsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsPost(ctx _context.Context) ApiApiAccountsMgmtV1SubscriptionsPostRequest {
	return ApiApiAccountsMgmtV1SubscriptionsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return Subscription
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsPostExecute(r ApiApiAccountsMgmtV1SubscriptionsPostRequest) (Subscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.subscriptionCreateRequest == nil {
		return localVarReturnValue, nil, reportError("subscriptionCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscriptionCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	subId      string
	accountId  string
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDelete Deletes a notification contact by subscription and account id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subId The id of subscription
 * @param accountId The id of account
 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDelete(ctx _context.Context, subId string, accountId string) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteRequest {
	return ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		subId:      subId,
		accountId:  accountId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsAccountIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{subId}/notification_contacts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"subId"+"}", _neturl.PathEscape(parameterToString(r.subId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", _neturl.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	subId      string
	page       *int32
	size       *int32
	search     *string
	fields     *string
	orderBy    *string
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest) Page(page int32) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest {
	r.page = &page
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest) Size(size int32) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest {
	r.size = &size
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest) Search(search string) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest {
	r.search = &search
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest) Fields(fields string) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest {
	r.fields = &fields
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest) OrderBy(orderBy string) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest) Execute() (AccountList, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGet Returns a list of notification contacts for the given subscription
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subId The id of subscription
 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGet(ctx _context.Context, subId string) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest {
	return ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest{
		ApiService: a,
		ctx:        ctx,
		subId:      subId,
	}
}

/*
 * Execute executes the request
 * @return AccountList
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGetRequest) (AccountList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccountList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{subId}/notification_contacts"
	localVarPath = strings.Replace(localVarPath, "{"+"subId"+"}", _neturl.PathEscape(parameterToString(r.subId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest struct {
	ctx                              _context.Context
	ApiService                       DefaultApi
	subId                            string
	notificationContactCreateRequest *NotificationContactCreateRequest
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest) NotificationContactCreateRequest(notificationContactCreateRequest NotificationContactCreateRequest) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest {
	r.notificationContactCreateRequest = &notificationContactCreateRequest
	return r
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest) Execute() (Account, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPost Add an account as a notification contact to this subscription
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subId The id of subscription
 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPost(ctx _context.Context, subId string) ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest {
	return ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest{
		ApiService: a,
		ctx:        ctx,
		subId:      subId,
	}
}

/*
 * Execute executes the request
 * @return Account
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPostRequest) (Account, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsSubIdNotificationContactsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{subId}/notification_contacts"
	localVarPath = strings.Replace(localVarPath, "{"+"subId"+"}", _neturl.PathEscape(parameterToString(r.subId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.notificationContactCreateRequest == nil {
		return localVarReturnValue, nil, reportError("notificationContactCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationContactCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetRequest struct {
	ctx                _context.Context
	ApiService         DefaultApi
	subId              string
	reservedResourceId string
}

func (r ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetRequest) Execute() (ReservedResource, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetExecute(r)
}

/*
 * ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGet Get reserved resources by id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subId The id of subscription
 * @param reservedResourceId The id of reserved resource
 * @return ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGet(ctx _context.Context, subId string, reservedResourceId string) ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetRequest {
	return ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetRequest{
		ApiService:         a,
		ctx:                ctx,
		subId:              subId,
		reservedResourceId: reservedResourceId,
	}
}

/*
 * Execute executes the request
 * @return ReservedResource
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetExecute(r ApiApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGetRequest) (ReservedResource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReservedResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SubscriptionsSubIdReservedResourcesReservedResourceIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/subscriptions/{subId}/reserved_resources/{reservedResourceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"subId"+"}", _neturl.PathEscape(parameterToString(r.subId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservedResourceId"+"}", _neturl.PathEscape(parameterToString(r.reservedResourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SupportCasesCaseIdDeleteRequest struct {
	ctx        _context.Context
	ApiService DefaultApi
	caseId     string
}

func (r ApiApiAccountsMgmtV1SupportCasesCaseIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SupportCasesCaseIdDeleteExecute(r)
}

/*
 * ApiAccountsMgmtV1SupportCasesCaseIdDelete Delete a support case
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param caseId The id of a support case
 * @return ApiApiAccountsMgmtV1SupportCasesCaseIdDeleteRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SupportCasesCaseIdDelete(ctx _context.Context, caseId string) ApiApiAccountsMgmtV1SupportCasesCaseIdDeleteRequest {
	return ApiApiAccountsMgmtV1SupportCasesCaseIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		caseId:     caseId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SupportCasesCaseIdDeleteExecute(r ApiApiAccountsMgmtV1SupportCasesCaseIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SupportCasesCaseIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/support_cases/{caseId}"
	localVarPath = strings.Replace(localVarPath, "{"+"caseId"+"}", _neturl.PathEscape(parameterToString(r.caseId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1SupportCasesPostRequest struct {
	ctx                 _context.Context
	ApiService          DefaultApi
	supportCasesRequest *SupportCasesRequest
}

func (r ApiApiAccountsMgmtV1SupportCasesPostRequest) SupportCasesRequest(supportCasesRequest SupportCasesRequest) ApiApiAccountsMgmtV1SupportCasesPostRequest {
	r.supportCasesRequest = &supportCasesRequest
	return r
}

func (r ApiApiAccountsMgmtV1SupportCasesPostRequest) Execute() (SupportCasesCreatedResponse, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1SupportCasesPostExecute(r)
}

/*
 * ApiAccountsMgmtV1SupportCasesPost create a support case for the subscription
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1SupportCasesPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SupportCasesPost(ctx _context.Context) ApiApiAccountsMgmtV1SupportCasesPostRequest {
	return ApiApiAccountsMgmtV1SupportCasesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SupportCasesCreatedResponse
 */
func (a *DefaultApiService) ApiAccountsMgmtV1SupportCasesPostExecute(r ApiApiAccountsMgmtV1SupportCasesPostRequest) (SupportCasesCreatedResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SupportCasesCreatedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1SupportCasesPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/support_cases"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.supportCasesRequest == nil {
		return localVarReturnValue, nil, reportError("supportCasesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.supportCasesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAccountsMgmtV1TokenAuthorizationPostRequest struct {
	ctx                       _context.Context
	ApiService                DefaultApi
	tokenAuthorizationRequest *TokenAuthorizationRequest
}

func (r ApiApiAccountsMgmtV1TokenAuthorizationPostRequest) TokenAuthorizationRequest(tokenAuthorizationRequest TokenAuthorizationRequest) ApiApiAccountsMgmtV1TokenAuthorizationPostRequest {
	r.tokenAuthorizationRequest = &tokenAuthorizationRequest
	return r
}

func (r ApiApiAccountsMgmtV1TokenAuthorizationPostRequest) Execute() (TokenAuthorizationResponse, *_nethttp.Response, error) {
	return r.ApiService.ApiAccountsMgmtV1TokenAuthorizationPostExecute(r)
}

/*
 * ApiAccountsMgmtV1TokenAuthorizationPost Finds the account owner of the provided token
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAccountsMgmtV1TokenAuthorizationPostRequest
 */
func (a *DefaultApiService) ApiAccountsMgmtV1TokenAuthorizationPost(ctx _context.Context) ApiApiAccountsMgmtV1TokenAuthorizationPostRequest {
	return ApiApiAccountsMgmtV1TokenAuthorizationPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return TokenAuthorizationResponse
 */
func (a *DefaultApiService) ApiAccountsMgmtV1TokenAuthorizationPostExecute(r ApiApiAccountsMgmtV1TokenAuthorizationPostRequest) (TokenAuthorizationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TokenAuthorizationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAccountsMgmtV1TokenAuthorizationPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts_mgmt/v1/token_authorization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.tokenAuthorizationRequest == nil {
		return localVarReturnValue, nil, reportError("tokenAuthorizationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tokenAuthorizationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAuthorizationsV1AccessReviewPostRequest struct {
	ctx          _context.Context
	ApiService   DefaultApi
	accessReview *AccessReview
}

func (r ApiApiAuthorizationsV1AccessReviewPostRequest) AccessReview(accessReview AccessReview) ApiApiAuthorizationsV1AccessReviewPostRequest {
	r.accessReview = &accessReview
	return r
}

func (r ApiApiAuthorizationsV1AccessReviewPostRequest) Execute() (AccessReviewResponse, *_nethttp.Response, error) {
	return r.ApiService.ApiAuthorizationsV1AccessReviewPostExecute(r)
}

/*
 * ApiAuthorizationsV1AccessReviewPost Review an account's access to perform an action on a particular resource or resource type
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAuthorizationsV1AccessReviewPostRequest
 */
func (a *DefaultApiService) ApiAuthorizationsV1AccessReviewPost(ctx _context.Context) ApiApiAuthorizationsV1AccessReviewPostRequest {
	return ApiApiAuthorizationsV1AccessReviewPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return AccessReviewResponse
 */
func (a *DefaultApiService) ApiAuthorizationsV1AccessReviewPostExecute(r ApiApiAuthorizationsV1AccessReviewPostRequest) (AccessReviewResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccessReviewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAuthorizationsV1AccessReviewPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authorizations/v1/access_review"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.accessReview == nil {
		return localVarReturnValue, nil, reportError("accessReview is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accessReview
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAuthorizationsV1CapabilityReviewPostRequest struct {
	ctx                     _context.Context
	ApiService              DefaultApi
	capabilityReviewRequest *CapabilityReviewRequest
}

func (r ApiApiAuthorizationsV1CapabilityReviewPostRequest) CapabilityReviewRequest(capabilityReviewRequest CapabilityReviewRequest) ApiApiAuthorizationsV1CapabilityReviewPostRequest {
	r.capabilityReviewRequest = &capabilityReviewRequest
	return r
}

func (r ApiApiAuthorizationsV1CapabilityReviewPostRequest) Execute() (CapabilityReview, *_nethttp.Response, error) {
	return r.ApiService.ApiAuthorizationsV1CapabilityReviewPostExecute(r)
}

/*
 * ApiAuthorizationsV1CapabilityReviewPost Review an account's capabilities
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAuthorizationsV1CapabilityReviewPostRequest
 */
func (a *DefaultApiService) ApiAuthorizationsV1CapabilityReviewPost(ctx _context.Context) ApiApiAuthorizationsV1CapabilityReviewPostRequest {
	return ApiApiAuthorizationsV1CapabilityReviewPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return CapabilityReview
 */
func (a *DefaultApiService) ApiAuthorizationsV1CapabilityReviewPostExecute(r ApiApiAuthorizationsV1CapabilityReviewPostRequest) (CapabilityReview, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CapabilityReview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAuthorizationsV1CapabilityReviewPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authorizations/v1/capability_review"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.capabilityReviewRequest == nil {
		return localVarReturnValue, nil, reportError("capabilityReviewRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.capabilityReviewRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAuthorizationsV1ExportControlReviewPostRequest struct {
	ctx                        _context.Context
	ApiService                 DefaultApi
	exportControlReviewRequest *ExportControlReviewRequest
}

func (r ApiApiAuthorizationsV1ExportControlReviewPostRequest) ExportControlReviewRequest(exportControlReviewRequest ExportControlReviewRequest) ApiApiAuthorizationsV1ExportControlReviewPostRequest {
	r.exportControlReviewRequest = &exportControlReviewRequest
	return r
}

func (r ApiApiAuthorizationsV1ExportControlReviewPostRequest) Execute() (ExportControlReview, *_nethttp.Response, error) {
	return r.ApiService.ApiAuthorizationsV1ExportControlReviewPostExecute(r)
}

/*
 * ApiAuthorizationsV1ExportControlReviewPost Determine whether a user is restricted from downloading Red Hat software based on export control compliance.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAuthorizationsV1ExportControlReviewPostRequest
 */
func (a *DefaultApiService) ApiAuthorizationsV1ExportControlReviewPost(ctx _context.Context) ApiApiAuthorizationsV1ExportControlReviewPostRequest {
	return ApiApiAuthorizationsV1ExportControlReviewPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return ExportControlReview
 */
func (a *DefaultApiService) ApiAuthorizationsV1ExportControlReviewPostExecute(r ApiApiAuthorizationsV1ExportControlReviewPostRequest) (ExportControlReview, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExportControlReview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAuthorizationsV1ExportControlReviewPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authorizations/v1/export_control_review"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.exportControlReviewRequest == nil {
		return localVarReturnValue, nil, reportError("exportControlReviewRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.exportControlReviewRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAuthorizationsV1ResourceReviewPostRequest struct {
	ctx                   _context.Context
	ApiService            DefaultApi
	resourceReviewRequest *ResourceReviewRequest
}

func (r ApiApiAuthorizationsV1ResourceReviewPostRequest) ResourceReviewRequest(resourceReviewRequest ResourceReviewRequest) ApiApiAuthorizationsV1ResourceReviewPostRequest {
	r.resourceReviewRequest = &resourceReviewRequest
	return r
}

func (r ApiApiAuthorizationsV1ResourceReviewPostRequest) Execute() (ResourceReview, *_nethttp.Response, error) {
	return r.ApiService.ApiAuthorizationsV1ResourceReviewPostExecute(r)
}

/*
 * ApiAuthorizationsV1ResourceReviewPost Obtain resource ids for resources an account may perform the specified action upon. Resource ids returned as [\"*\"] is shorthand for all ids.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAuthorizationsV1ResourceReviewPostRequest
 */
func (a *DefaultApiService) ApiAuthorizationsV1ResourceReviewPost(ctx _context.Context) ApiApiAuthorizationsV1ResourceReviewPostRequest {
	return ApiApiAuthorizationsV1ResourceReviewPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return ResourceReview
 */
func (a *DefaultApiService) ApiAuthorizationsV1ResourceReviewPostExecute(r ApiApiAuthorizationsV1ResourceReviewPostRequest) (ResourceReview, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceReview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAuthorizationsV1ResourceReviewPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authorizations/v1/resource_review"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.resourceReviewRequest == nil {
		return localVarReturnValue, nil, reportError("resourceReviewRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resourceReviewRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAuthorizationsV1SelfAccessReviewPostRequest struct {
	ctx              _context.Context
	ApiService       DefaultApi
	selfAccessReview *SelfAccessReview
}

func (r ApiApiAuthorizationsV1SelfAccessReviewPostRequest) SelfAccessReview(selfAccessReview SelfAccessReview) ApiApiAuthorizationsV1SelfAccessReviewPostRequest {
	r.selfAccessReview = &selfAccessReview
	return r
}

func (r ApiApiAuthorizationsV1SelfAccessReviewPostRequest) Execute() (AccessReviewResponse, *_nethttp.Response, error) {
	return r.ApiService.ApiAuthorizationsV1SelfAccessReviewPostExecute(r)
}

/*
 * ApiAuthorizationsV1SelfAccessReviewPost Review your ability to perform an action on a particular resource or resource type
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAuthorizationsV1SelfAccessReviewPostRequest
 */
func (a *DefaultApiService) ApiAuthorizationsV1SelfAccessReviewPost(ctx _context.Context) ApiApiAuthorizationsV1SelfAccessReviewPostRequest {
	return ApiApiAuthorizationsV1SelfAccessReviewPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return AccessReviewResponse
 */
func (a *DefaultApiService) ApiAuthorizationsV1SelfAccessReviewPostExecute(r ApiApiAuthorizationsV1SelfAccessReviewPostRequest) (AccessReviewResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccessReviewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAuthorizationsV1SelfAccessReviewPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authorizations/v1/self_access_review"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.selfAccessReview == nil {
		return localVarReturnValue, nil, reportError("selfAccessReview is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selfAccessReview
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAuthorizationsV1SelfResourceReviewPostRequest struct {
	ctx                       _context.Context
	ApiService                DefaultApi
	selfResourceReviewRequest *SelfResourceReviewRequest
}

func (r ApiApiAuthorizationsV1SelfResourceReviewPostRequest) SelfResourceReviewRequest(selfResourceReviewRequest SelfResourceReviewRequest) ApiApiAuthorizationsV1SelfResourceReviewPostRequest {
	r.selfResourceReviewRequest = &selfResourceReviewRequest
	return r
}

func (r ApiApiAuthorizationsV1SelfResourceReviewPostRequest) Execute() (SelfResourceReview, *_nethttp.Response, error) {
	return r.ApiService.ApiAuthorizationsV1SelfResourceReviewPostExecute(r)
}

/*
 * ApiAuthorizationsV1SelfResourceReviewPost Obtain resource ids for resources you may perform the specified action upon. Resource ids returned as [\"*\"] is shorthand for all ids.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAuthorizationsV1SelfResourceReviewPostRequest
 */
func (a *DefaultApiService) ApiAuthorizationsV1SelfResourceReviewPost(ctx _context.Context) ApiApiAuthorizationsV1SelfResourceReviewPostRequest {
	return ApiApiAuthorizationsV1SelfResourceReviewPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SelfResourceReview
 */
func (a *DefaultApiService) ApiAuthorizationsV1SelfResourceReviewPostExecute(r ApiApiAuthorizationsV1SelfResourceReviewPostRequest) (SelfResourceReview, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SelfResourceReview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAuthorizationsV1SelfResourceReviewPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authorizations/v1/self_resource_review"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.selfResourceReviewRequest == nil {
		return localVarReturnValue, nil, reportError("selfResourceReviewRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selfResourceReviewRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAuthorizationsV1SelfTermsReviewPostRequest struct {
	ctx             _context.Context
	ApiService      DefaultApi
	selfTermsReview *SelfTermsReview
}

func (r ApiApiAuthorizationsV1SelfTermsReviewPostRequest) SelfTermsReview(selfTermsReview SelfTermsReview) ApiApiAuthorizationsV1SelfTermsReviewPostRequest {
	r.selfTermsReview = &selfTermsReview
	return r
}

func (r ApiApiAuthorizationsV1SelfTermsReviewPostRequest) Execute() (TermsReviewResponse, *_nethttp.Response, error) {
	return r.ApiService.ApiAuthorizationsV1SelfTermsReviewPostExecute(r)
}

/*
 * ApiAuthorizationsV1SelfTermsReviewPost Review your status of Terms
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAuthorizationsV1SelfTermsReviewPostRequest
 */
func (a *DefaultApiService) ApiAuthorizationsV1SelfTermsReviewPost(ctx _context.Context) ApiApiAuthorizationsV1SelfTermsReviewPostRequest {
	return ApiApiAuthorizationsV1SelfTermsReviewPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return TermsReviewResponse
 */
func (a *DefaultApiService) ApiAuthorizationsV1SelfTermsReviewPostExecute(r ApiApiAuthorizationsV1SelfTermsReviewPostRequest) (TermsReviewResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TermsReviewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAuthorizationsV1SelfTermsReviewPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authorizations/v1/self_terms_review"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.selfTermsReview == nil {
		return localVarReturnValue, nil, reportError("selfTermsReview is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selfTermsReview
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiAuthorizationsV1TermsReviewPostRequest struct {
	ctx         _context.Context
	ApiService  DefaultApi
	termsReview *TermsReview
}

func (r ApiApiAuthorizationsV1TermsReviewPostRequest) TermsReview(termsReview TermsReview) ApiApiAuthorizationsV1TermsReviewPostRequest {
	r.termsReview = &termsReview
	return r
}

func (r ApiApiAuthorizationsV1TermsReviewPostRequest) Execute() (TermsReviewResponse, *_nethttp.Response, error) {
	return r.ApiService.ApiAuthorizationsV1TermsReviewPostExecute(r)
}

/*
 * ApiAuthorizationsV1TermsReviewPost Review an account's status of Terms
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiAuthorizationsV1TermsReviewPostRequest
 */
func (a *DefaultApiService) ApiAuthorizationsV1TermsReviewPost(ctx _context.Context) ApiApiAuthorizationsV1TermsReviewPostRequest {
	return ApiApiAuthorizationsV1TermsReviewPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return TermsReviewResponse
 */
func (a *DefaultApiService) ApiAuthorizationsV1TermsReviewPostExecute(r ApiApiAuthorizationsV1TermsReviewPostRequest) (TermsReviewResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TermsReviewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApiAuthorizationsV1TermsReviewPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authorizations/v1/terms_review"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.termsReview == nil {
		return localVarReturnValue, nil, reportError("termsReview is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.termsReview
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
