/*
 * Apicurio Registry API [v2]
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 2.0.1-SNAPSHOT
 * Contact: apicurio@lists.jboss.org
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package srsdata

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"os"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type ArtifactsApi interface {

	/*
			 * CreateArtifact Create artifact
			 * Creates a new artifact by posting the artifact content.  The body of the request should
		be the raw content of the artifact.  This is typically in JSON format for *most* of the
		supported types, but may be in another format for a few (for example, `PROTOBUF`).

		The registry attempts to figure out what kind of artifact is being added from the
		following supported list:

		* Avro (`AVRO`)
		* Protobuf (`PROTOBUF`)
		* JSON Schema (`JSON`)
		* Kafka Connect (`KCONNECT`)
		* OpenAPI (`OPENAPI`)
		* AsyncAPI (`ASYNCAPI`)
		* GraphQL (`GRAPHQL`)
		* Web Services Description Language (`WSDL`)
		* XML Schema (`XSD`)

		Alternatively, you can specify the artifact type using the `X-Registry-ArtifactType`
		HTTP request header, or include a hint in the request's `Content-Type`.  For example:

		```
		Content-Type: application/json; artifactType=AVRO
		```

		An artifact is created using the content provided in the body of the request.  This
		content is created under a unique artifact ID that can be provided in the request
		using the `X-Registry-ArtifactId` request header.  If not provided in the request,
		the server generates a unique ID for the artifact.  It is typically recommended
		that callers provide the ID, because this is typically a meaningful identifier,
		and for most use cases should be supplied by the caller.

		If an artifact with the provided artifact ID already exists, the default behavior
		is for the server to reject the content with a 409 error.  However, the caller can
		supply the `ifExists` query parameter to alter this default behavior. The `ifExists`
		query parameter can have one of the following values:

		* `FAIL` (*default*) - server rejects the content with a 409 error
		* `UPDATE` - server updates the existing artifact and returns the new metadata
		* `RETURN` - server does not create or add content to the server, but instead
		returns the metadata for the existing artifact
		* `RETURN_OR_UPDATE` - server returns an existing **version** that matches the
		provided content if such a version exists, otherwise a new version is created

		This operation may fail for one of the following reasons:

		* An invalid `ArtifactType` was indicated (HTTP error `400`)
		* No `ArtifactType` was indicated and the server could not determine one from the content (HTTP error `400`)
		* Provided content (request body) was empty (HTTP error `400`)
		* An artifact with the provided ID already exists (HTTP error `409`)
		* The content violates one of the configured global rules (HTTP error `409`)
		* A server error occurred (HTTP error `500`)

			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @param groupId Unique ID of an artifact group.
			 * @return ApiCreateArtifactRequest
	*/
	CreateArtifact(ctx _context.Context, groupId string) ApiCreateArtifactRequest

	/*
	 * CreateArtifactExecute executes the request
	 * @return ArtifactMetaData
	 */
	CreateArtifactExecute(r ApiCreateArtifactRequest) (ArtifactMetaData, *_nethttp.Response, error)

	/*
			 * DeleteArtifact Delete artifact
			 * Deletes an artifact completely, resulting in all versions of the artifact also being
		deleted.  This may fail for one of the following reasons:

		* No artifact with the `artifactId` exists (HTTP error `404`)
		* A server error occurred (HTTP error `500`)
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
			 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
			 * @return ApiDeleteArtifactRequest
	*/
	DeleteArtifact(ctx _context.Context, groupId string, artifactId string) ApiDeleteArtifactRequest

	/*
	 * DeleteArtifactExecute executes the request
	 */
	DeleteArtifactExecute(r ApiDeleteArtifactRequest) (*_nethttp.Response, error)

	/*
	 * DeleteArtifactsInGroup Deletes all artifacts in a group
	 * Deletes all of the artifacts that exist in a given group.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param groupId Unique ID of an artifact group.
	 * @return ApiDeleteArtifactsInGroupRequest
	 */
	DeleteArtifactsInGroup(ctx _context.Context, groupId string) ApiDeleteArtifactsInGroupRequest

	/*
	 * DeleteArtifactsInGroupExecute executes the request
	 */
	DeleteArtifactsInGroupExecute(r ApiDeleteArtifactsInGroupRequest) (*_nethttp.Response, error)

	/*
			 * GetContentById Get artifact content by ID
			 * Gets the content for an artifact version in the registry using the unique content
		identifier for that content.  This content ID may be shared by multiple artifact
		versions in the case where the artifact versions are identical.

		This operation may fail for one of the following reasons:

		* No content with this `contentId` exists (HTTP error `404`)
		* A server error occurred (HTTP error `500`)

			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @param contentId Global identifier for a single artifact content.
			 * @return ApiGetContentByIdRequest
	*/
	GetContentById(ctx _context.Context, contentId int64) ApiGetContentByIdRequest

	/*
	 * GetContentByIdExecute executes the request
	 * @return *os.File
	 */
	GetContentByIdExecute(r ApiGetContentByIdRequest) (*os.File, *_nethttp.Response, error)

	/*
			 * GetLatestArtifact Get latest artifact
			 * Returns the latest version of the artifact in its raw form.  The `Content-Type` of the
		response depends on the artifact type.  In most cases, this is `application/json`, but
		for some types it may be different (for example, `PROTOBUF`).

		This operation may fail for one of the following reasons:

		* No artifact with this `artifactId` exists (HTTP error `404`)
		* A server error occurred (HTTP error `500`)

			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
			 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
			 * @return ApiGetLatestArtifactRequest
	*/
	GetLatestArtifact(ctx _context.Context, groupId string, artifactId string) ApiGetLatestArtifactRequest

	/*
	 * GetLatestArtifactExecute executes the request
	 * @return *os.File
	 */
	GetLatestArtifactExecute(r ApiGetLatestArtifactRequest) (*os.File, *_nethttp.Response, error)

	/*
	 * ListArtifactsInGroup List artifacts in group
	 * Returns a list of all artifacts in the group.  This list is paged.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param groupId Unique ID of an artifact group.
	 * @return ApiListArtifactsInGroupRequest
	 */
	ListArtifactsInGroup(ctx _context.Context, groupId string) ApiListArtifactsInGroupRequest

	/*
	 * ListArtifactsInGroupExecute executes the request
	 * @return ArtifactSearchResults
	 */
	ListArtifactsInGroupExecute(r ApiListArtifactsInGroupRequest) (ArtifactSearchResults, *_nethttp.Response, error)

	/*
			 * UpdateArtifact Update artifact
			 * Updates an artifact by uploading new content.  The body of the request should
		be the raw content of the artifact.  This is typically in JSON format for *most*
		of the supported types, but may be in another format for a few (for example, `PROTOBUF`).
		The type of the content should be compatible with the artifact's type (it would be
		an error to update an `AVRO` artifact with new `OPENAPI` content, for example).

		The update could fail for a number of reasons including:

		* Provided content (request body) was empty (HTTP error `400`)
		* No artifact with the `artifactId` exists (HTTP error `404`)
		* The new content violates one of the rules configured for the artifact (HTTP error `409`)
		* A server error occurred (HTTP error `500`)

		When successful, this creates a new version of the artifact, making it the most recent
		(and therefore official) version of the artifact.
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
			 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
			 * @return ApiUpdateArtifactRequest
	*/
	UpdateArtifact(ctx _context.Context, groupId string, artifactId string) ApiUpdateArtifactRequest

	/*
	 * UpdateArtifactExecute executes the request
	 * @return ArtifactMetaData
	 */
	UpdateArtifactExecute(r ApiUpdateArtifactRequest) (ArtifactMetaData, *_nethttp.Response, error)
}

// ArtifactsApiService ArtifactsApi service
type ArtifactsApiService service

type ApiCreateArtifactRequest struct {
	ctx                   _context.Context
	ApiService            ArtifactsApi
	groupId               string
	body                  **os.File
	xRegistryArtifactType *ArtifactType
	xRegistryArtifactId   *string
	xRegistryVersion      *string
	ifExists              *IfExists
	canonical             *bool
}

func (r ApiCreateArtifactRequest) Body(body *os.File) ApiCreateArtifactRequest {
	r.body = &body
	return r
}
func (r ApiCreateArtifactRequest) XRegistryArtifactType(xRegistryArtifactType ArtifactType) ApiCreateArtifactRequest {
	r.xRegistryArtifactType = &xRegistryArtifactType
	return r
}
func (r ApiCreateArtifactRequest) XRegistryArtifactId(xRegistryArtifactId string) ApiCreateArtifactRequest {
	r.xRegistryArtifactId = &xRegistryArtifactId
	return r
}
func (r ApiCreateArtifactRequest) XRegistryVersion(xRegistryVersion string) ApiCreateArtifactRequest {
	r.xRegistryVersion = &xRegistryVersion
	return r
}
func (r ApiCreateArtifactRequest) IfExists(ifExists IfExists) ApiCreateArtifactRequest {
	r.ifExists = &ifExists
	return r
}
func (r ApiCreateArtifactRequest) Canonical(canonical bool) ApiCreateArtifactRequest {
	r.canonical = &canonical
	return r
}

func (r ApiCreateArtifactRequest) Execute() (ArtifactMetaData, *_nethttp.Response, error) {
	return r.ApiService.CreateArtifactExecute(r)
}

/*
 * CreateArtifact Create artifact
 * Creates a new artifact by posting the artifact content.  The body of the request should
be the raw content of the artifact.  This is typically in JSON format for *most* of the
supported types, but may be in another format for a few (for example, `PROTOBUF`).

The registry attempts to figure out what kind of artifact is being added from the
following supported list:

* Avro (`AVRO`)
* Protobuf (`PROTOBUF`)
* JSON Schema (`JSON`)
* Kafka Connect (`KCONNECT`)
* OpenAPI (`OPENAPI`)
* AsyncAPI (`ASYNCAPI`)
* GraphQL (`GRAPHQL`)
* Web Services Description Language (`WSDL`)
* XML Schema (`XSD`)

Alternatively, you can specify the artifact type using the `X-Registry-ArtifactType`
HTTP request header, or include a hint in the request's `Content-Type`.  For example:

```
Content-Type: application/json; artifactType=AVRO
```

An artifact is created using the content provided in the body of the request.  This
content is created under a unique artifact ID that can be provided in the request
using the `X-Registry-ArtifactId` request header.  If not provided in the request,
the server generates a unique ID for the artifact.  It is typically recommended
that callers provide the ID, because this is typically a meaningful identifier,
and for most use cases should be supplied by the caller.

If an artifact with the provided artifact ID already exists, the default behavior
is for the server to reject the content with a 409 error.  However, the caller can
supply the `ifExists` query parameter to alter this default behavior. The `ifExists`
query parameter can have one of the following values:

* `FAIL` (*default*) - server rejects the content with a 409 error
* `UPDATE` - server updates the existing artifact and returns the new metadata
* `RETURN` - server does not create or add content to the server, but instead
returns the metadata for the existing artifact
* `RETURN_OR_UPDATE` - server returns an existing **version** that matches the
provided content if such a version exists, otherwise a new version is created

This operation may fail for one of the following reasons:

* An invalid `ArtifactType` was indicated (HTTP error `400`)
* No `ArtifactType` was indicated and the server could not determine one from the content (HTTP error `400`)
* Provided content (request body) was empty (HTTP error `400`)
* An artifact with the provided ID already exists (HTTP error `409`)
* The content violates one of the configured global rules (HTTP error `409`)
* A server error occurred (HTTP error `500`)

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId Unique ID of an artifact group.
 * @return ApiCreateArtifactRequest
*/
func (a *ArtifactsApiService) CreateArtifact(ctx _context.Context, groupId string) ApiCreateArtifactRequest {
	return ApiCreateArtifactRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
	}
}

/*
 * Execute executes the request
 * @return ArtifactMetaData
 */
func (a *ArtifactsApiService) CreateArtifactExecute(r ApiCreateArtifactRequest) (ArtifactMetaData, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ArtifactMetaData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtifactsApiService.CreateArtifact")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/service-registry/v2/groups/{groupId}/artifacts"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.ifExists != nil {
		localVarQueryParams.Add("ifExists", parameterToString(*r.ifExists, ""))
	}
	if r.canonical != nil {
		localVarQueryParams.Add("canonical", parameterToString(*r.canonical, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRegistryArtifactType != nil {
		localVarHeaderParams["X-Registry-ArtifactType"] = parameterToString(*r.xRegistryArtifactType, "")
	}
	if r.xRegistryArtifactId != nil {
		localVarHeaderParams["X-Registry-ArtifactId"] = parameterToString(*r.xRegistryArtifactId, "")
	}
	if r.xRegistryVersion != nil {
		localVarHeaderParams["X-Registry-Version"] = parameterToString(*r.xRegistryVersion, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v RuleViolationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteArtifactRequest struct {
	ctx        _context.Context
	ApiService ArtifactsApi
	groupId    string
	artifactId string
}

func (r ApiDeleteArtifactRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteArtifactExecute(r)
}

/*
 * DeleteArtifact Delete artifact
 * Deletes an artifact completely, resulting in all versions of the artifact also being
deleted.  This may fail for one of the following reasons:

* No artifact with the `artifactId` exists (HTTP error `404`)
* A server error occurred (HTTP error `500`)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
 * @return ApiDeleteArtifactRequest
*/
func (a *ArtifactsApiService) DeleteArtifact(ctx _context.Context, groupId string, artifactId string) ApiDeleteArtifactRequest {
	return ApiDeleteArtifactRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
		artifactId: artifactId,
	}
}

/*
 * Execute executes the request
 */
func (a *ArtifactsApiService) DeleteArtifactExecute(r ApiDeleteArtifactRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtifactsApiService.DeleteArtifact")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/service-registry/v2/groups/{groupId}/artifacts/{artifactId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artifactId"+"}", _neturl.PathEscape(parameterToString(r.artifactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteArtifactsInGroupRequest struct {
	ctx        _context.Context
	ApiService ArtifactsApi
	groupId    string
}

func (r ApiDeleteArtifactsInGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteArtifactsInGroupExecute(r)
}

/*
 * DeleteArtifactsInGroup Deletes all artifacts in a group
 * Deletes all of the artifacts that exist in a given group.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId Unique ID of an artifact group.
 * @return ApiDeleteArtifactsInGroupRequest
 */
func (a *ArtifactsApiService) DeleteArtifactsInGroup(ctx _context.Context, groupId string) ApiDeleteArtifactsInGroupRequest {
	return ApiDeleteArtifactsInGroupRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
	}
}

/*
 * Execute executes the request
 */
func (a *ArtifactsApiService) DeleteArtifactsInGroupExecute(r ApiDeleteArtifactsInGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtifactsApiService.DeleteArtifactsInGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/service-registry/v2/groups/{groupId}/artifacts"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetContentByIdRequest struct {
	ctx        _context.Context
	ApiService ArtifactsApi
	contentId  int64
}

func (r ApiGetContentByIdRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.GetContentByIdExecute(r)
}

/*
 * GetContentById Get artifact content by ID
 * Gets the content for an artifact version in the registry using the unique content
identifier for that content.  This content ID may be shared by multiple artifact
versions in the case where the artifact versions are identical.

This operation may fail for one of the following reasons:

* No content with this `contentId` exists (HTTP error `404`)
* A server error occurred (HTTP error `500`)

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param contentId Global identifier for a single artifact content.
 * @return ApiGetContentByIdRequest
*/
func (a *ArtifactsApiService) GetContentById(ctx _context.Context, contentId int64) ApiGetContentByIdRequest {
	return ApiGetContentByIdRequest{
		ApiService: a,
		ctx:        ctx,
		contentId:  contentId,
	}
}

/*
 * Execute executes the request
 * @return *os.File
 */
func (a *ArtifactsApiService) GetContentByIdExecute(r ApiGetContentByIdRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtifactsApiService.GetContentById")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/service-registry/v2/ids/contentIds/{contentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentId"+"}", _neturl.PathEscape(parameterToString(r.contentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLatestArtifactRequest struct {
	ctx        _context.Context
	ApiService ArtifactsApi
	groupId    string
	artifactId string
}

func (r ApiGetLatestArtifactRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.GetLatestArtifactExecute(r)
}

/*
 * GetLatestArtifact Get latest artifact
 * Returns the latest version of the artifact in its raw form.  The `Content-Type` of the
response depends on the artifact type.  In most cases, this is `application/json`, but
for some types it may be different (for example, `PROTOBUF`).

This operation may fail for one of the following reasons:

* No artifact with this `artifactId` exists (HTTP error `404`)
* A server error occurred (HTTP error `500`)

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
 * @return ApiGetLatestArtifactRequest
*/
func (a *ArtifactsApiService) GetLatestArtifact(ctx _context.Context, groupId string, artifactId string) ApiGetLatestArtifactRequest {
	return ApiGetLatestArtifactRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
		artifactId: artifactId,
	}
}

/*
 * Execute executes the request
 * @return *os.File
 */
func (a *ArtifactsApiService) GetLatestArtifactExecute(r ApiGetLatestArtifactRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtifactsApiService.GetLatestArtifact")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/service-registry/v2/groups/{groupId}/artifacts/{artifactId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artifactId"+"}", _neturl.PathEscape(parameterToString(r.artifactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListArtifactsInGroupRequest struct {
	ctx        _context.Context
	ApiService ArtifactsApi
	groupId    string
	limit      *int32
	offset     *int32
	order      *SortOrder
	orderby    *SortBy
}

func (r ApiListArtifactsInGroupRequest) Limit(limit int32) ApiListArtifactsInGroupRequest {
	r.limit = &limit
	return r
}
func (r ApiListArtifactsInGroupRequest) Offset(offset int32) ApiListArtifactsInGroupRequest {
	r.offset = &offset
	return r
}
func (r ApiListArtifactsInGroupRequest) Order(order SortOrder) ApiListArtifactsInGroupRequest {
	r.order = &order
	return r
}
func (r ApiListArtifactsInGroupRequest) Orderby(orderby SortBy) ApiListArtifactsInGroupRequest {
	r.orderby = &orderby
	return r
}

func (r ApiListArtifactsInGroupRequest) Execute() (ArtifactSearchResults, *_nethttp.Response, error) {
	return r.ApiService.ListArtifactsInGroupExecute(r)
}

/*
 * ListArtifactsInGroup List artifacts in group
 * Returns a list of all artifacts in the group.  This list is paged.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId Unique ID of an artifact group.
 * @return ApiListArtifactsInGroupRequest
 */
func (a *ArtifactsApiService) ListArtifactsInGroup(ctx _context.Context, groupId string) ApiListArtifactsInGroupRequest {
	return ApiListArtifactsInGroupRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
	}
}

/*
 * Execute executes the request
 * @return ArtifactSearchResults
 */
func (a *ArtifactsApiService) ListArtifactsInGroupExecute(r ApiListArtifactsInGroupRequest) (ArtifactSearchResults, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ArtifactSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtifactsApiService.ListArtifactsInGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/service-registry/v2/groups/{groupId}/artifacts"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.order, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("orderby", parameterToString(*r.orderby, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateArtifactRequest struct {
	ctx              _context.Context
	ApiService       ArtifactsApi
	groupId          string
	artifactId       string
	body             **os.File
	xRegistryVersion *string
}

func (r ApiUpdateArtifactRequest) Body(body *os.File) ApiUpdateArtifactRequest {
	r.body = &body
	return r
}
func (r ApiUpdateArtifactRequest) XRegistryVersion(xRegistryVersion string) ApiUpdateArtifactRequest {
	r.xRegistryVersion = &xRegistryVersion
	return r
}

func (r ApiUpdateArtifactRequest) Execute() (ArtifactMetaData, *_nethttp.Response, error) {
	return r.ApiService.UpdateArtifactExecute(r)
}

/*
 * UpdateArtifact Update artifact
 * Updates an artifact by uploading new content.  The body of the request should
be the raw content of the artifact.  This is typically in JSON format for *most*
of the supported types, but may be in another format for a few (for example, `PROTOBUF`).
The type of the content should be compatible with the artifact's type (it would be
an error to update an `AVRO` artifact with new `OPENAPI` content, for example).

The update could fail for a number of reasons including:

* Provided content (request body) was empty (HTTP error `400`)
* No artifact with the `artifactId` exists (HTTP error `404`)
* The new content violates one of the rules configured for the artifact (HTTP error `409`)
* A server error occurred (HTTP error `500`)

When successful, this creates a new version of the artifact, making it the most recent
(and therefore official) version of the artifact.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
 * @return ApiUpdateArtifactRequest
*/
func (a *ArtifactsApiService) UpdateArtifact(ctx _context.Context, groupId string, artifactId string) ApiUpdateArtifactRequest {
	return ApiUpdateArtifactRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
		artifactId: artifactId,
	}
}

/*
 * Execute executes the request
 * @return ArtifactMetaData
 */
func (a *ArtifactsApiService) UpdateArtifactExecute(r ApiUpdateArtifactRequest) (ArtifactMetaData, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ArtifactMetaData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtifactsApiService.UpdateArtifact")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/service-registry/v2/groups/{groupId}/artifacts/{artifactId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artifactId"+"}", _neturl.PathEscape(parameterToString(r.artifactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRegistryVersion != nil {
		localVarHeaderParams["X-Registry-Version"] = parameterToString(*r.xRegistryVersion, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
