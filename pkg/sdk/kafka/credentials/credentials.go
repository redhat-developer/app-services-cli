package credentials

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"

	"github.com/bf2fc6cc711aee1a0c2a/cli/pkg/api/builders"
	"github.com/bf2fc6cc711aee1a0c2a/cli/pkg/api/managedservices"
	"github.com/bf2fc6cc711aee1a0c2a/cli/pkg/config"
)

// Templates
const (
	templateProperties = `
## Credentials for Kafka cluster: '%v' 
## Generated by rhoas cli
kafka_user=%v
kafka_password=%v
`

	templateEnv = `
## Credentials for Kafka cluster: '%v' 
## Generated by rhoas cli
KAFKA_USER=%v
KAFKA_PASSWORD=%v
`

	templateKafkaPlain = `
## Credentials for Kafka cluster: '%v' 
## Generated by rhoas cli
kafka.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username="%v" password="%v";
kafka.sasl.mechanism=PLAIN
kafka.security.protocol=SASL_SSL
kafka.ssl.protocol=TLSv1.2
`

	templateJSON = `
{ 
	"name":"%v",
	"user":"%v", 
	"password":"%v" 
}
`
)

func RunCredentials(outputFlagValue string, force bool) {
	var fileFormat string
	var fileName string

	switch outputFlagValue {
	case "env":
		fileFormat = templateEnv
		fileName = ".env"
	case "properties":
		fileFormat = templateProperties
		fileName = "kafka.properties"
	case "kafka":
		fileFormat = templateKafkaPlain
		fileName = "kafka.properties"
	case "json":
		fileFormat = templateJSON
		fileName = "credentials.json"
	}

	client := builders.BuildClient()
	response, _, err := client.DefaultApi.CreateServiceAccount(context.Background())

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating Kafka Credentials: %v\n", err)
		return
	}

	cfg, err := config.Load()
	if err != nil {
		fmt.Fprint(os.Stderr, "Invalid configuration file", err)
	}

	jsonResponse, _ := json.Marshal(response)
	var credentials managedservices.TokenResponse
	err = json.Unmarshal(jsonResponse, &credentials)
	if err != nil {
		fmt.Fprint(os.Stderr, "Invalid response from server", err)
	}

	fmt.Fprintf(os.Stderr, "Writing credentials to %v \n", fileName)
	fileContent := fmt.Sprintf(fileFormat, cfg.Services.Kafka.ClusterName, credentials.ClientID, credentials.ClientSecret)

	dataToWrite := []byte(fileContent)

	if fileExists(fileName) && !force {
		fmt.Fprintf(os.Stderr, "File %v already exist. Use --force flag to override file.\n", fileName)
		return
	}

	err = ioutil.WriteFile(fileName, dataToWrite, 0600)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error when saving file %v \n", err)
	} else {
		fmt.Fprintf(os.Stderr, "Successfully saved credentials to %v \n", fileName)
	}
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return !os.IsNotExist(err)
}
